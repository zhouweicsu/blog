[{"title":"「原」图解 JavaScript 中的 __proto__ 与 prototype","date":"2017-03-02T08:22:13.000Z","path":"2017/03/02/proto-prototype/","text":"正真理解 JavaScript 中的原型模式是掌握 JavaScript 基础的关键。原型模式是 JavaScript 实现面向对象和继承的基础。而原型中的 __proto__ 与 prototype 又是理解原型模式的关键。 本文用代码结合图片的方式梳理一下 proto 和 prototype 之间的区别和关系。 MDN 中写到： 当谈到继承时，JavaScript 只有一种结构：对象。每个对象都有一个内部链接到另一个对象，称为它的原型 prototype。该原型对象有自己的原型，等等，直到达到一个以 null 为原型的对象。根据定义，null 没有原型，并且作为这个原型链 prototype chain 中的最终链接。 《JavaScript 高级程序设计》第 6 章 6.2.3 原型模式中写到： 当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262 第 5 版中称这个指针叫 [[Prototype]]。 大多数浏览器得 ES5 实现中都支持通过属性 proto 来访问 [[Prototype]] 指针。 先看一段代码：1234567891011121314151617181920212223242526272829class Point&#123; constructor(x,y) &#123; this.x = x; this.y = y; &#125;&#125;class ColorPoint extends Point &#123; constructor(x,y,color) &#123; super(x, y); this.color = color; &#125;&#125;var p1 = new Point(2,3);var p2 = new ColorPoint(3,4, 'green');console.log(p1.__proto__ === Point.prototype); //trueconsole.log(p1.__proto__.__proto__ === Object.prototype); //trueconsole.log(p2.__proto__ === ColorPoint.prototype); //trueconsole.log(p2.__proto__.__proto__ === Point.prototype); //trueconsole.log(Point.__proto__ === Function.prototype); //trueconsole.log(ColorPoint.prototype.__proto__ === Point.prototype); //trueconsole.log(ColorPoint.__proto__ == Point); //trueconsole.log(Function.prototype === Function.__proto__); //trueconsole.log(Function.prototype.__proto__ === Object.prototype); //trueconsole.log(Object.prototype.__proto__) //nullconsole.log(Object.prototype.prototype) //undefinedconsole.log(p1.prototype) //undefined Class 可看作为构造函数的语法糖。 根据这段代码我们可以绘制出如下关系图： 结论从图中可以看到实例、函数和原型对象之间的关系，得到以下结论： 实例、构造函数和原型对象都有 __proto__ 属性，（JavaScript 中所有对象都有此属性，JavaScript 中一切皆对象），指向该对象的构造函数的原型对象； 构造函数不仅有 __proto__ 属性，还有 prototype 属性（函数独有属性），prototype 指向该构造函数的原型对象（Note：通过 Function.prototype.bind 方法构造出来的函数是个例外，它没有 prototype 属性）； 原型链最终指向一个以 null 为原型的对象。null 没有原型，并且作为这个原型链 prototype chain 中的最终链接； Function 的 prototype 和 __proto__ 都指向 Function.prototype； 参考文章：js 中 __proto__ 和 prototype 的区别和关系？","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zhouweicsu.github.io/blog/tags/JavaScript/"},{"name":"面试","slug":"面试","permalink":"http://zhouweicsu.github.io/blog/tags/面试/"}]},{"title":"「译」面试中要注意的 3 个 JavaScript 问题","date":"2017-02-21T16:00:00.000Z","path":"2017/02/22/3-javascript-questions-to-watch-out-for-during-coding-interviews/","text":"JavaScript 是所有现代浏览器的官方语言。因此，各种语言的开发者面试中都会遇到 JavaScript 问题。 本文不讲最新的 JavaScript 库，通用开发实践，或任何新的 ES6 函数。而是讲讲面试中经常出现的 3 个 JavaScript 问题。我问过这些问题，我的朋友说他们也问。 当然不是说你在准备 JavaScript 面试时只要学习这 3 个问题 —— 你还有很多途径去更好的准备即将到来的面试 —— 但面试官很有可能通过下面 3 个问题来判断你了解和掌握 JavaScript 和 DOM 的情况。 让我们开始吧！注意下面的例子中我们使用原生 JavaScript， 因为面试官通常想考查你在不借助库（例如 jQuery）的帮助时掌握 JavaScript 和 DOM 的情况。 问题 #1： 事件代理创建应用时，有时需要给页面中的按钮，文字，或图片添加事件监听器，当用户与这些元素交互时触发某些操作。 我们以一个简单的代办事项列表为例，面试官会告诉你，他们希望在用户点击列表中某一项时触发一个动作。并让你用 JavaScript 根据下面的 HTML 代码实现这个功能： 123456&lt;ul id=\"todo-app\"&gt; &lt;li class=\"item\"&gt;Walk the dog&lt;/li&gt; &lt;li class=\"item\"&gt;Pay bills&lt;/li&gt; &lt;li class=\"item\"&gt;Make dinner&lt;/li&gt; &lt;li class=\"item\"&gt;Code for one hour&lt;/li&gt;&lt;/ul&gt; 你可能会像下面的代码一样给元素添加事件监听器： 12345678910111213document.addEventListener(&apos;DOMContentLoaded&apos;, function() &#123; let app = document.getElementById(&apos;todo-app&apos;); let items = app.getElementsByClassName(&apos;item&apos;); // 给每个列表项添加事件监听器 for (let item of items) &#123; item.addEventListener(&apos;click&apos;, function() &#123; alert(&apos;you clicked on item: &apos; + item.innerHTML); &#125;); &#125; &#125;); 当然上面的代码能完成面试官的需求，问题是每个列表项都会加上一个事件监听器。当列表只有 4 项时没有问题，但如果有人给代办事项列表新增了 10,000 个事项呢（他们也许有一大堆事情要做）？那时函数会创建 10,000 个事件监听器，然后把它们都添加到 DOM 上。这样效率非常低。 面试中最好首先问一下面试官用户最多可以添加多少个代办事项。如果永远不会超过 10 个，那上面的代码运行起来就没有问题。但如果用户输入待办事项的数量没有上限，那你就得换一个更高效的解决方案。 如果应用有上百个事件监听器，更高效的解决方案是给最外层的容器添加一个事件监听器，当用户真正点击的时候再去获取实际被点击的代办事项。这被称为事件代理，这比给每个代办事项都单独添加事件监听器更高效。 下面是事件代理的代码： 12345678910111213document.addEventListener(&apos;DOMContentLoaded&apos;, function() &#123; let app = document.getElementById(&apos;todo-app&apos;); // 给容器添加事件监听器 app.addEventListener(&apos;click&apos;, function(e) &#123; if (e.target &amp;&amp; e.target.nodeName === &apos;LI&apos;) &#123; let item = e.target; alert(&apos;you clicked on item: &apos; + item.innerHTML); &#125; &#125;); &#125;); 问题 #2: 在循环中使用闭包面试中经常会问到闭包，因为面试官能通过这个问题的回答判断你对语言的熟悉程度，以及考察你是否知道什么时候使用闭包。 闭包就是能访问作用域外部变量的内部函数 。闭包能用来实现私有化和创建工厂函数等作用。关于闭包的常见面试题是这样的： 写一个函数，循环一个整数数组，延迟 3 秒打印这个数组中每个元素的索引。 这个问题常见（不正确）的实现是这样： 123456const arr = [10, 12, 15, 21];for (var i = 0; i &lt; arr.length; i++) &#123; setTimeout(function() &#123; console.log('The index of this number is: ' + i); &#125;, 3000);&#125; 如果你运行这段函数，你会发现 3 秒之后每次都打印的是 4，而不是预期的 0, 1, 2, 3。 为了正确的找到出现这种情况的原因，你需要理解 JavaScript 是如何运行这段代码的，这也是面试官想要考察你的地方。 原因是 setTimeout 函数创建了一个访问外部作用域的函数（闭包），就是包含索引 i 的那个循环。3 秒之后，函数开始执行打印 i 的值，而此时循环也结束了，i 的值已经是 4。因为循环遍历 0, 1, 2, 3, 4 后最终停在了 4。 实际上有好几种方法能正确解决这个问题。这里有两个： 123456789const arr = [10, 12, 15, 21];for (var i = 0; i &lt; arr.length; i++) &#123; // 给每个函数传入变量 i 让其能访问正确的索引 setTimeout(function(i_local) &#123; return function() &#123; console.log(&apos;The index of this number is: &apos; + i_local); &#125; &#125;(i), 3000);&#125; 12345678const arr = [10, 12, 15, 21];for (let i = 0; i &lt; arr.length; i++) &#123; // 使用 ES6 中的 let 关键字，它会在函数调用时创建一个新的绑定 // 了解更多：http://exploringjs.com/es6/ch_variables.html#sec_let-const-loop-heads setTimeout(function() &#123; console.log(&apos;The index of this number is: &apos; + i); &#125;, 3000);&#125; 问题 #3： Debouncing（防抖动）有些浏览器事件能在很短的时间内被触发多次，例如调整窗口大小或滚动页面。如果你给窗口滚动事件添加一个事件监听器，然后用户不停地快速向下滚动页面，那你的事件可能在 3 秒之内被触发数千次。这会导致非常严重的性能问题。 如果在面试中讨论到构建应用程序，以及滚动事件，窗口调整事件，或者键盘事件等，请务必提及 debouncing 或者 throttling，作为提高页面速度与性能的方法。来一个 css-tricks 的实例： 2011 年，Twitter 出了一个问题：当滚动 Twitter 摘要时，页面变的很卡甚至无响应。John Resig 写了一篇关于这个问题的博客，解释了直接将耗时的函数绑定在 scroll 事件上是一个多么糟糕的想法。 Debouncing 是解决这个问题的一种方法，它的做法是限制下次函数调用之前必须等待的时间间隔。正确实现 debouncing 的方法是将若干个函数调用 合成 一次，并在给定时间过去之后仅被调用一次。下面是一个原生 JavaScript 的实现，用到了作用域, 闭包, this, 和 计时事件： 12345678910111213141516// 将会包装事件的 debounce 函数function debounce(fn, delay) &#123; // 维护一个 timer let timer = null; // 能访问 timer 的闭包 return function() &#123; // 通过 ‘this’ 和 ‘arguments’ 获取函数的作用域和变量 let context = this; let args = arguments; // 如果事件被调用，清除 timer 然后重新设置 timer clearTimeout(timer); timer = setTimeout(function() &#123; fn.apply(context, args); &#125;, delay); &#125;&#125; 这个函数 — 当传入一个事件（fn）时 — 会在经过给定的时间（delay）后执行。 函数这样用： 12345678// 当用户滚动时被调用的函数function foo() &#123; console.log(&apos;You are scrolling!&apos;);&#125;// 在 debounce 中包装我们的函数，过 2 秒触发一次let elem = document.getElementById(&apos;container&apos;);elem.addEventListener(&apos;scroll&apos;, debounce(foo, 2000)); Throttling 是与 debouncing 类似的一种技术，但它不是在调用函数之前等待一段时间，throttling 是在较长的时间间隔内调用函数。所以如果一个事件每 100 毫秒被触发 10 次，throttling 会在每隔 2 秒时执行一次这个函数，而不是在 100 毫秒内执行 10 次事件。 更多关于 debouncing 和 throttling 的信息请参考以下文章和教程： JavaScript 中的 Throttling 和 Debouncing Throttling 与 Debouncing 的区别 实例解析 Throttling 和 Debouncing Throttling 函数调用 —— Remy Sharp 如果你喜欢阅读这篇文章，那你或许也喜欢阅读 JavaScript 教程，参与我在 Coderbyte 上主持的 JavaScript 编码挑战。期待你的想法！","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zhouweicsu.github.io/blog/tags/JavaScript/"},{"name":"翻译","slug":"翻译","permalink":"http://zhouweicsu.github.io/blog/tags/翻译/"},{"name":"面试","slug":"面试","permalink":"http://zhouweicsu.github.io/blog/tags/面试/"}]},{"title":"「译」可扩展 Web 宣言","date":"2017-02-12T16:00:00.000Z","path":"2017/02/13/the-extensible-web-manifesto/","text":"推动 Web 发展我们——已签署这份协议的人——想要改变 Web 标准委员会新增新特性以及给他们排优先级的方式。我们认为这对 Web 的长期健康发展来说至关重要。 我们的目标是缩小 Web 标准与 Web 开发者之间的反馈环路。 目前，许多新特性需要经历几个月甚至几年的标准化流程，接着又是浏览器厂商的精确实现，然后才是开发者的反馈与迭代。我们更希望先进行 JavaScript 新特性的开发与迭代，然后再是浏览器厂商的实现和标准化过程。 为了让函数库能做更多的事情，浏览器厂商应该提供新的底层原语，尽可能多的暴露访问平台底层的接口。 厂商还应该通过新特性的 JavaScript 实现，来促成开发者对高级 API 的讨论（例如 Mozilla’s X-Tags 和 Google’s Polymer）。 具体而言，我们为可扩展 Web 平台提议以下设计准则： 专注于向 Web 平台新增安全高效的底层原语。 暴露底层原语解释现有特性，例如 HTML 和 CSS，使开发者能理解并复用他们。 在 JavaScript 新的高级特性成为标准之前，让 Web 开发者参与其开发，设计和测试的迭代过程。这会在标准和开发者之间形成良性循环。 优先处理符合这些建议的工作，降低不符合这些建议的优先级或重新评估他们。 专注于标准化新的底层原语，并基于这些原语来扩展新特性，我们倡导： 考虑新的安全领域。 浏览器引擎的优化工作应集中在稳定内核，因为内核会影响许多新增的 API。这样做会减少实现成本并提升性能。 浏览器厂商和函数库的开发者应共同参与函数库的迭代开发，以提供浏览器友好的高级 API。 根据底层原语解释已存在和未来的特性，我们倡导： 减缓实现过程中复杂度的增长率，这样 bug 数的增长也会放缓。 尽可能给平台的新特性实现 polyfill。 新特性应该让开发者付出尽可能少的学习成本。学习资料应该由平台中现有的概念组成。 让新特性易于理解，易于 polyfill 会形成良性循环，因为： 开发者可以快速了解新的 API，让平台在 API 最具扩展性的时候获得更快的反馈。 在开发者使用和函数库作者提供服务的过程中，API 中错误能被快速修正，这给浏览器厂商和平台设计者提供了高保真和很关键的反馈。 函数库的作者可以尝试新的 API，为平台发展提供更多的道路。 优先工作应该遵循那些准则，我们倡导： 放手标准制作的过程（尤其是短期内），致力于有关安全或性能问题的特性，以及仅能在平台级别新增的特性，例如新的硬件。 让 Web 开发者和初始化浏览器的函数库去引领代价高昂的探索。 那些已经有实现，且在实际项目中已大量使用过的 API ，我们需要简化其冗长的标准化过程。 我们希望 Web 开发者能写更多声明式代码。这就需要引入新的声明式形式来打破现有标准的限制，并为函数库和框架的作者提供创建他们的工具。 为了让开放式 Web 能够竞争过其铜墙铁壁般的对手，我们需要提供一条清晰的路径，让 Web 开发者能够将他们的好想法变成 Web 基础的一部分。必须让 Web 开发者去构建未来的 Web 世界。 如果你支持这些原则， 请点击这里签名 已签名名单 Brendan Eich Mozilla CTO 和 高级副总裁; JavaScript 创造者 Yehuda Katz TC39, W3C TAG 会员； Ember.js, Rails 核心团队成员 Alex Russell TC39, W3C TAG 会员；Google Chrome 团队成员 Brian Kardell W3C 可扩展的 Web 社区小组主席 François REMY W3C 可扩展的 Web 社区小组联合创始人 Clint Hill W3C 可扩展的 Web 社区小组联合创始人 Marcos Caceres W3C 可扩展的 Web 社区小组联合创始人 Tom Dale Ember.js 核心团队成员 Anne van Kesteren 标准编辑，Mozilla 架构师 Sam Tobin-Hochstadt TC39 会员 Domenic Denicola Promises/A+ 标准的联合作者 Chris Eppstein Sass 维护者 Dave Herman Mozilla 研究员，TC39 Alan Stearns CSSWG 会员 Rick Waldron TC39 会员；jQuery, Bocoup 核心团队成员 Paul Irish Google Ted Han DocumentCloud 开发负责人 Tab Atkins CSSWG 会员； Google Dan Appelquist W3C TAG 联合主席， Telefónica 开放 Web 倡导者 Isaac Schlueter Node.js 维护者 Allen Wirfs-Brock Mozilla 研究员， TC39 会员， ECMAScript 规范编辑 相关阅读 Extend the Web Forward，作者 Yehuda Katz，更详细地解释了宣言中提到的理念。 An Extensible Approach to Browser Security Policy，作者 Yehuda Katz，该文为宣言中关于浏览器内容安全策略的 API 设计问题提供了一个实际可行的方案。 Dropping the F-Bomb on Web Standards，作者 Brian Kardell，一份关于开发者社区的想法和语言如何被纳入可交互的标准中的务实讨论。 Bedrock，作者 Alex Russell，一篇 2012 年的文章，深入探讨以可扩展（“分层”）方式设计平台的理论与实践。 How the Web Should Work，作者 Boris Smus，一篇 2012 年的文章，描述了“forward polyfills”（或者 prollyfills）应该如何实际应用。","tags":[{"name":"翻译","slug":"翻译","permalink":"http://zhouweicsu.github.io/blog/tags/翻译/"},{"name":"Web","slug":"Web","permalink":"http://zhouweicsu.github.io/blog/tags/Web/"}]},{"title":"「译」我的智能浴室镜","date":"2016-07-18T16:00:00.000Z","path":"2016/07/19/my-bathroom-mirror-is-smarter-than-yours/","text":"买不到智能镜就自己做一个去年年底某个时候，我觉得浴室里的镜子得像电影里未来世界中长的那样。 但似乎市场上没有人卖我想要的这种镜子。然而，组成镜子的每个零部件都很常见。最近也有很多人做了类似的自制智能浴室镜，但我想象中的与这些有些不同。 所以我自己订购了一个双面镜，一个展示板，一个控制面板，外加一些组件和手工艺术品。实际上，做好这个镜子之前我进行了相当多的实验，许多实验失败了，还是让我们看看完成的（但绝不是最终的）作品： 欢迎来到我的浴室，请忽略药柜旁边我已经精心整理过的杂七杂八和那个普通的镜面。 镜子的右边是时间和日期。左边是当前的天气以及 24 小时的预报。下面是最近的新闻头条。来个特写： 除了多云的天气，其他天气的时候 UI 会有一些色彩，但为了避免太分散注意力，大部分文字和图标都是单色的。 这些 UI 的实现使用了一些简单的安卓 API（例如：这个很不错），天气预报的 API 和美联社的新闻订阅。 其他我正在尝试的有交通情况，事件提醒，以及任何有 Google Now card 的东西。我的观点就是你不必与这些 UI 交互。因为他会自动更新，谷歌还提供了一个开放的语音搜索接口，你想搜什么就可以搜什么。 嵌入双面镜与药柜门之间的展示板只有薄薄的几毫米。这样会很整洁，我还能继续使用柜子里的空间。下图是以一定角度打开门拍的图，你可以看一下边缘处： 这个原型还在不断改进，我还没有花太多时间在软件上。上面提到的 UI 也仅有几百行代码，我还尝试使用不同的设备来运行它——一开始是 Chromecast，后来使用了 Nexus Player，最近用的是 Fire TV Stick。 我把这些电子设备固定在平板上并整理了一下，要不然看上去会一团糟： 以上是这个项目目前的所有进展。期待实现剩余的一些想法。也许我还会更新制作过程中一些更详细的图片。","tags":[{"name":"翻译","slug":"翻译","permalink":"http://zhouweicsu.github.io/blog/tags/翻译/"},{"name":"mirror","slug":"mirror","permalink":"http://zhouweicsu.github.io/blog/tags/mirror/"}]},{"title":"「译」以变应变","date":"2016-07-04T16:00:00.000Z","path":"2016/07/05/fit-to-scale/","text":"我的网站现在是响应式的。与弹性图片、弹性布局和媒体查询一起工作的越久，我对取得的成果评价就越高。在为 Do Lectures website 网站做重新设计时，我对“响应式方案是否应该与设计以及 Paravel 的工作流（Paravel 是作者所在的公司，一家位于德克萨斯州奥斯汀的网页设计公司。—— 译者注）保持一致”的所有认知被全部颠覆了。我们不必大改整个流程，还可以控制预算，还能保证网站结构从台式电脑到移动设备都保持完好。由于在这个项目获取的积极意义的经验，我决定把我学到的以及关于本网站形成的观点写一篇文章。 距 Ethan Marcotte 的分水岭级文章 A List Apart：响应式 Web 设计已经快一年了，从那以后每当看到我的网站在我妻子的笔记本电脑上出现横向滚动条时我都备受折磨。对响应式的喜爱是因为他的理念，就是无论手机、全屏桌面还是介于两者之间的任何一种设备都可以访问网站。如果说人们不会用网站宽度一半的设备访问网站，那绝对是在逃避问题。人们不会，那是因为我们没有提供这种访问的可能性。然而我依然推荐用户使用全屏访问，不可否认无论是同时对比两篇文章，还是在文本编辑器窗口旁打开一个参考网页都是十分方便的。 结构完整性如果说之前有什么顾虑的话，也不是关于响应式设计本身，而是一些我曾经看到过的响应式实例。在大部分情况下，屏幕调整时页面元素糟糕的剧烈调整会误导用户。诚然，当 3 列变成 1 列时有些东西必须放弃，但是网站的结构和层级必须仍然保留。如果用户第一次使用网站全宽的设备访问，当使用较窄窗口的浏览器或者移动设备再次访问时，他们应该也能认识该网站且能轻松自如的访问。个人认为这应该被认为 UX 设计的另一个组成部分。 我们花费了如此多的时间讨论决定页面上每个元素的位置，那为什么当窗口变窄时就让所有这些工作都付诸东流呢？响应式 Web 设计不是适应内容（就像重新装填搬家货车），而是裁剪内容去适应用户（就像布置家具）。当设备宽度变化时，内容与布局要优雅的缩放。 FitText 简介我喜欢对 Web 字体排版和响应式进行细微控制，但我很担心这两者不能共存。如何让字符，单词或者行的位置微调也变成可缩放的？当你想保留格式化的大标题和紧跟其后未被 h1 包裹 2 或 3 次的文章段落或图片之间的间距时会发生什么？即使是这个网站，也仍然有一些地方的依赖文本的布局不管窗口大小都显示成全宽度。我知道 Lettering.js 需要一个插件了，带着这个想法我去找 Paravel 的小伙伴 Dave Rupert。第二天他给我介绍了 FitText！ 我真的想挑战一下自己，让之前写的文章适应新的响应式布局。过程中每篇文章都会暴露出一个待解决的独特问题集，未解决的问题都被 FitText 处理了。该 jQuery 插件放大 web 类型来适应其父元素。不管窗口大小文本总显示成全宽度。FitText 能与 Lettering.js 或任何 CSS3 属性（本文标题就是一个例子）完美搭配，不用说你也永远不会在段落文本上使用 FitText（我希望你不要这样用），但是在适当的位置，FitText 能让响应式 Web 设计令人更加兴奋。 我的关键属性现在本网站是响应式的，我打算继续拿他当练兵场 —— 持续改进我的计划和针对内容的设计。从旧的设计方法转变到 web 响应式并不是自动的，在真正得出效果最佳的方案前还有一些令人兴奋的工作。我所有的文章都有他们自己一个小而独特的样式表，在使每篇博客在任何宽度的设备上看起来都好的路上我学了很多东西。下面是一些真正支撑本网站更新的属性： backgroun-size 的百分比能帮我直观地、无缝地缩放旧文章中的网页结构，插图和文字图片。 用垂直 padding 或 margins 代替垂直 height，这样保持标题栏的高宽比会变得非常简单。 Column-count 依然不是很可靠，但在 tags 模块通过媒体查询，Column-count 简化了 4 栏布局变成 3 栏再到 2 栏的过渡过程。当这个和 flex-box 都时机成熟时，代码产出将会异常高效。 Ok，这些对目前来说足够了。我会写更多关于响应式 Web 设计和 FitText 的文章。同时，点一点我的博客或使用 FitText 创建一些自己的东西。感谢阅读，希望你喜欢这篇更新！ 2011 年 5 月 10 日","tags":[{"name":"CSS","slug":"CSS","permalink":"http://zhouweicsu.github.io/blog/tags/CSS/"},{"name":"scale","slug":"scale","permalink":"http://zhouweicsu.github.io/blog/tags/scale/"},{"name":"fluid","slug":"fluid","permalink":"http://zhouweicsu.github.io/blog/tags/fluid/"}]},{"title":"「译」使用 vh 和 vw 实现正真的流式文字排版","date":"2016-06-28T16:00:00.000Z","path":"2016/06/29/fluid-typography/","text":"实现流式文字排版或许比你想象的更简单。他具有广泛的浏览器支持，实现简单，而且实现之后并不会让你失去对设计的整体把控。 不像响应式文字排版，文字只在指定的几个分界点才会调整，流式文字排版则能平滑地调整文字来适应任何宽度的设备。当网站需要支持几乎无限个屏幕尺寸的时候，流式排版就是不二之选。然而，由于一些原因，他的普及率却仍远不及响应式技术。 也许是因为文字排版受印刷排版的古老历史影响太深。“流式”这个概念常常有违这些传统。在印刷业，尺寸通常是固定的，而 web 上却没有固定。这就是为什么我认为流式文字排版是 web 的完美搭档。他是截然不同的媒介的另一种处理方式。 但这并不意味着我们需要抛弃所有惯例和关于文字排版的一切。我们只需以稍微不同的方式学习如何应用一些我们已知的技术。谨慎对待每一个细节将确保我们在所有屏幕尺寸中都获得完美的设计体验。 流式文字排版快速入门视口单位是 web 上能应用流式文字排版的重要元素。视口单位指的是浏览器视口尺寸的百分比。例如，1 vw 等于视口宽度的 1%。与单位百分比不同，他们总是相对于视口，而百分比是相对于元素的父容器。 这意味着，与所有其他单位类型不同，视口单位与基础的字体大小没有任何关系。这个区别意义重大，也让这个单位变得有趣而独特。 可用的四个视口单位： vw: 视口宽度 vh: 视口高度 vmin: 视口宽度和高度的较小值 vmax: 视口宽度和高度的较大值 应用流式字体排版技术最简单的方法就是给 html 元素上的 font-size 设置一个流式单位： 1html &#123; font-size: 2vw; &#125; 在这个例子中，我们给根元素设置了 2vw。因此，我们改变了 “root em”。因为所有使用了 em 和 rem 单位的元素都直接或间接的与这个 root em 有关，所以他们也将变成流式的。例如： 1h1 &#123; font-size: 2em; &#125; 2em 的标题大小现在等于 4vw，因为这是当前基础字体大小 2vw 的两倍。 单独使用视口相关的单位也会带来一些弊端。例如我们无法精确控制缩放速率；无法设置最小或最大的字体大小；还有，与像素一样，一行声明也许会覆盖用户的 font-size 偏好设置。但幸运的是，总有方法来克服这些缺陷。 控制视口单位来设置最小与最大字体大小给 html 元素设置 2vw 让所有元素都流动起来然后收工回家，这么做当然简单，但这达不到最佳效果。视口单位是一个钝器，要得到可行结果需要一些外力辅助。 因为视口单位通常与视口有着直接的关系，所以在很小的屏幕下，你会看见小的离谱的字。 理论上，我们应该设置一个最小的字体大小，可惜 CSS 中并没有 min-font-size 这个属性。但换个角度思考一下，我们采用一些不同的方法也可以达到同样的效果。 第一，我们可以使用 calc() 表达式：1html &#123; font-size: calc(1em + 1vw); &#125; 在这个例子中，如果视口宽度为 0，那 font-size 就是 1em。当屏幕变大，1vw 的值将会与最小字体大小 1em 相加。但这个技巧并不是完美的；通常我们希望能在某个屏幕大小时设置一个最小的字体大小，而不是让他等于 0。使用媒体查询可以解决这个问题： 12345@media screen and (min-width: 50em) &#123; html &#123; font-size: 2vw; &#125;&#125; 在这个例子中，当视口宽度达到 50 em 的时候，字体大小就会变成动态的。这个方案效果很好，但在固定值和动态值之间通常会有一个抖动。为了消除这个抖动，我们要算出动态值与固定值刚好相等的那个视口宽度，然后在这个地方设置分界点。 如果默认的字体大小是 16 像素，2vw 是视口宽度的 2%，那么计算分界点的计算式就是 16 ÷ (2 ÷ 100)。结果是 800 像素。 2% * y = 16y = 16 ÷ (2 ÷ 100)——译者注 如果想在媒体查询中使用 em 单位，那就需要将 px 转换为 em。用 800 除以 16（或其他等于 rem 的像素值）： 800 ÷ 16 = 50。如果你觉得这更简单，也可以直接使用 em 作为单位来计算：1 ÷ (2 ÷ 100) = 50。如上例所示，设置一个 2vw 的字体大小和 50em 的分界点，可以使固定值与动态值无缝衔接。 同样的计算式也可计算出字体大小的最大值。如果想让字体大小最大不超过 24px，我们应该这样计算：24 ÷ (2 ÷ 100) = 1200px。使用 em 计算式就是：1.5 ÷ (2 ÷ 100) = 75（1.5 = 24 ÷ 16——译者注）。因此，超过 75em 的宽度后，字体大小就是固定值 1.5em。 12345@media screen and (min-width: 75em) &#123; html &#123; font-size: 1.5em; &#125;&#125; 这些计算式都不难，表格有助于直观的查看不同视口单位的分界点和字体缩放比例。表格头部是视口单位的值，表格左侧是设备解决方案。 - 1vw 2vw 3vw 4vw 5vw 400px 4px 8px 12px 16px 20px 500px 5px 10px 15px 20px 25px 600px 6px 12px 18px 24px 30px 700px 7px 14px 21px 28px 35px 800px 8px 16px 24px 32px 40px 通过表格可以看出，我们几乎无法控制视口单位大小改变时字体大小的改变速率。单独使用视口单位，字体大小就完全受限于表格的某一单列。 控制缩放速率如果想让字体大小在屏幕分辨率 400px 时为 16px，分辨率达到 800px 时调整到 24px，使用分界点实现不了这个需求。上面我们为最小和最大字体大小计算过分界点，不是选择他们。 那我们如何解决这个问题呢？答案就是使用 calc()。将 calc() 和视口单位结合使用可以得到进阶版流式文字排版，字体会在指定的视口范围内的指定像素值之间完美缩放。我们只需简单的创造一个基本的数学公式。 点击查看大图片 这个函数取指定范围内的一个值，然后计算出应用在不同范围的新值。所以，如果取数字 1 和 100 还有值 50，那么应用到 1 和 200 之间时，新值就是 100。而且这些值在范围中任何点都是正确的。 这是个很普通的映射函数，在 JavaScript 处理数据时已经使用过很多次。我很好奇将函数与 calc() 一起使用的可能性，当发现这就是纯数学函数时，我知道就缺一个变量了。这是使用视口的关键区别：视口大小就是变量。100vw 的值就是这个方程式的变量，因为当视口变化时 100vw 的值也是变化的。有了这个初始想法，我花了一段时间使得这个函数工作。calc() 函数以特定方式处理方程式中的单位类型。如果你对这类事情感兴趣，我极力推荐阅读 W3C 规范：单位的类型与值；如果不出意外，掌握这个你就可以去显摆了。 尽管这个计算式看起来有点复杂，但其实相当简单。我们选定最小字体大小和最大字体大小，最小屏幕尺寸和最大的屏幕尺寸，不是选定字体应该缩放的大小，然后将选定的值代入方程中。我们可以使用任何类型的单位，包括 em，rem 或 px。在文章的例子中我喜欢使用 px 这个单位，因为 px 让概念更容易理解，但在实际工作中我更喜欢使用 rem。但无论你选择哪个单位，都要保证方程式中所有的值都使用相同类型的单位，你必须剥离单位的影响，如例子所示。 如果你不想手写，网上有很多工具，比如 Sass 和 LESS 的 mixins，还有 PostCSS 的插件。你想怎么玩，就怎么玩。 维持完美行宽Robert 在他的书《印刷风格要素》中建议，一个令人感觉舒适的行宽大概是 45 到 75 个字符。 对于在正文中使用衬线字体（译者注：英语中的一种格式）的单栏页面来说，45 到 75 个字符被广泛认为是令人满意的行宽。66 个字符（包括字符与空格）则被公认为完美行宽。 这个规则可以直接复用到流式文字排版中，另外在许多情况下，随着文字的缩放实现一致的行宽也是有可能的。 在响应式方案中，我们通过设置分界点来调整字体大小，还会经常任意调整容器宽度来维持正确的行宽。然而，在流式文字排版中，指定分界点处的文字调整已经没有必要了。现在只需要设置容器宽度随着字体大小的变化速率而缩放就行。可以在 width 属性中使用 calc() 技术，与 font-size 的设置一样简单。这样就能轻松维持完美行宽——同时我也注意到样式表更容易阅读和维护了。 保持完美行宽在非常小的屏幕下是不切实际的。为了维护“完美的”阅读宽度而缩小字体，当缩小到某个点后总会损害可读性。我们只能接受这个事实，然后针对移动设备为某些关键内容的容器设置宽度。 实现一个模块化比例尺模块化比例尺就是一系列相互之间比例协调的数字。一图胜千言： 每个标题都比前一个标题的缩小了 1.2 倍（译者注：原文写的是 bigger，应该是错误的）。（点击查看大图） 不同的比例尺在不同尺寸的屏幕下效果更好。 （点击查看大图） 在小屏幕中，标题大小应该更统一；因为大屏幕有更多的空间应付更多样的变化。在不同的模块化比例尺之间，可以使用上文提到的动态变化的文字排版技术。只需为小屏幕选择一个比例尺，为大屏幕选择另一个比例尺，然后为每一个级别的标题计算出最小字体大小与最大字体大小。 为了计算出模块化比例尺，我们先取基础的字体大小与选定比例相乘得到一个更大的数字。除以选定比例得到一个较小的数字。根据得到的数字再重复此步骤，就会得到缩放过程中每个必需的值。 放大 1em × 1.125em = 1.125em 1.125em × 1.125em = 1.266em 1.266em × 1.125em = 1.424em 1.424em × 1.125em = 1.602em 缩小 1em ÷ 1.125em = 0.889em 0.889em ÷ 1.125em = 0.790em 0.790em ÷ 1.125em = 0.702em 0.702em ÷ 1.125em = 0.624em 我们取 1.125 作为最小缩放比例，取 1.250 作为最大缩放比例 ，然后做重复计算。然后在不同级别的标题中使用比例尺中的不同比例。 最小缩放比例： 1.125 最大缩放比例：1.250 标题级别 最小字体大小 最大字体大小 h1 1.602em 2.441em h2 1.424em 1.953em h3 1.266em 1.563em h4 1.125em 1.250em 我在 Codepen 上实现了一个流式模块化比例尺标题的例子。你还可以在 Tim Brown 的文章《更有意义的文字排版》中阅读更多关于模块化比例尺的内容。 如果你在选择合适的比例尺时需要帮助，我推荐 Jeremy Church 的网站 Type Scale 和 Tim Brown 与 Scott Kellum 的网站 Modular Scale。 保持垂直节奏垂直节奏就是让页面上的元素之间保持一致且成比例的间距。你可以在 Espen Brunborg 的文章《CSS 基线：好的，坏的和丑的》中找到更多关于垂直节奏的信息。 在流式布局中要保持垂直节奏，我们需要将每个元素的垂直间距设置为基准值的某个比例值。响应式文字排版中令许多人感到挑战的是如何找到在小屏幕和大屏幕下都能工作的垂直节奏。通常情况下，可以为小屏幕与大屏幕设置不同的基准值，也可以使用不同的比例。 在流式文字排版中，基准值也可以像字体大小一样设置为动态的。其实，如果已经给根元素设置了一个动态值，那我们就可以直接使用单位 em 或者 rem，也可以使用 calc() 。 假设基准值是 1.5rem。那么元素 body 的 padding 值就是 1.5rem。 123body &#123; padding: 1.5rem;&#125; 同样的，我们将 line-height 和 margin 也设置为 1.5rem。 1234p &#123; line-height: 1.5rem; margin-bottom: 1.5rem;&#125; 对于标题元素，我想设置一个不同的行高。然而，我又想让行高加上 margin 之后等于基准值的增量。这时 calc() 就派上用场了。 123456h1 &#123; font-size: 2rem; line-height: 2rem; margin-top: calc((1.5rem - 2rem) + 1.5rem); margin-bottom: 1.5rem;&#125; 在这个例子中，标题元素的总高度加上 margin 值将会是 3rem，刚好等于基准值的两倍。 我在 Codepen 上使用 Sass 变量写了一个例子，你可以设置不同的基准值来看看它是如何工作的。 未来，自定义 CSS 属性将会使得这个技巧更有趣。那时我们可以在 calc() 中使用 CSS 变量来改变媒体查询中的基线值。 如何处理限制条件也许你想在有布局限制的网站上实现流式文字排版，又或许你不得不使用 WordPress 或 Bootstrap 中的预定义布局。在这些情况下，容器很有可能不是流式的，如果是，大概也不会与字体大小以同速率变化。 我最近为澳大利亚政府民政部门的网站实现流式文字排版。这是个充满挑战的大网站，我们还必须基于现有的设计工作。在这样一个访问量巨大的网站上实现流式文字排版，我主要关注两个问题。 第一，我如何避免破坏布局？尤其是当字体大小以不同速率变化时我以为导航容器中的内容会溢出。但令我惊讶的是，这根本不是个问题。 实际上，内容可以自然地调整以适应容器，而在之前需要指定分界点来调整。总之，样式表需要更少的媒体查询，并且在大部分情况下，组件也需要的样式声明比原来少得多。 这是个意外收获，我们还在许多地方抛弃了对平板电脑的优化设计，因为桌面版现在也能在更小的屏幕上工作了。 下面是一个之前需要在不同屏幕尺寸中需要若干调整的导航组件实例。虽然在小屏幕下不完美，但字体紧凑，功能健全，也没有破坏布局。 (点击查看大图) 我的第二个问题是，有些元素是固定宽度，我也知道不可能每一行都达到完美行宽。实际上，我将字体大小调整为手机和平板上面的完美长度 —— 我认为这是最重要的。 还有不得不接受的情况是，由于主容器没有以和文字以同速率缩放，一些文字可能在浏览器调整大小的时候不可避免地回流。之所以称之为一个问题，是因为我不想让读者在旋转设备时丢失他们的阅读焦点。但因为我们无法避免这个问题，所以我们唯一能做的就是在指定设备上测试一下有多少影响。很幸运的是回流在移动设备上几乎很难被注意到，甚至在大的平板电脑上这个影响也是极小的。 我们对最终的效果很满意。然而我们可以做更多来提升字体排版，毫无疑问这么做提升了网站的可读性。鉴于从实现流式字体排版中吸取的教训，该网站设计的下一个迭代应主要关注字体如何排版以及网站的可读性方面。 在已有网站上实现流式文字排版的建议 认真地选择缩放比例、最小和最大字体大小，确保能与你的设计完美契合。 字体大小使用单位 em。如果你需要在某一特定容器中禁用流式文字排版，例如导航栏，那么可将容器的字体大小设为一个固定值。这时该容器中单位为 em 的值将与这个固定值相关。 同样地，如果你需要给某一特定容器设置流式字体排版。那你可以给该容器的字体大小设置一个不定值，那容器中单位为 em 的值会变成流式的。 如果文字回流只发生在浏览器调整大小或设备旋转的时候，那没必要把它当作一个坏事情。 保持完美行宽是不可能的。主要考虑手机和平板电脑的完美行宽就行。 浏览器支持与 Bugs我经常听说 Safari，尤其是移动版 Safari，在使用视口单位和 calc() 表达式时都有严重的 bug。然而，很多时候都没有提到具体问题，所以我想我得自己测试。 我分别测试了 calc() 表达式和视口单位，以及结合了视口单位和 calc() 的进阶版流式字体排版技术。但我没有发现任何阻止我使用这些技术的问题。 calc() 和视口单位在高级浏览器上都能正常工作。但是在低于 Safari8 和 IE11 的版本里，当 calc() 表达式中使用了视口单位时，浏览器窗口改变时不会重新计算结果。 你可以通过额外的媒体查询来强制表达式重新计算： 123456789101112131415/* 老版本浏览器 */html &#123; font-size: 16px; &#125;/* 高级浏览器只需要下面这个*/@media screen and (min-width: 25em)&#123; html &#123; font-size: calc( 16px + (24 - 16) * (100vw - 400px) / (800 - 400) ); &#125;&#125;/* Safari &lt;8 和 IE &lt;11 */@media screen and (min-width: 25em)&#123; html &#123; font-size: calc( 16px + (24 - 16) * (100vw - 400px) / (800 - 400) ); &#125;&#125;@media screen and (min-width: 50em)&#123; html &#123; font-size: calc( 16px + (24 - 16) * (100vw - 400px) / (800 - 400) ); &#125;&#125; 这个技术强制低于 Safari8 和 IE11 的浏览器在指定分界点处重新计算字体大小。 在 JavaScript 中使用窗口重绘事件来强制低版本浏览器重新布局也许可以，但我还没有找到一个可依赖方法来这么做，还有这样做可能会影响性能。在大多数情况下，在指定分界点处重新计算是这些浏览器可接受的一个降级方案。 对于那些不支持视口单位和 calc() 表达式的古董浏览器，流式技术可以直接忽略。如果设置了合理的默认值，这些技术也可以作为渐进增强方案。 今天如何使用流式字体排版如果你计划实现流式字体排版，首先你得确定采用哪种方法。 如果整个设计都是流式的，那你可以考虑将 root em 设置为流式的，通过在元素 html 上声明一个使用流式单位的字体大小。然后，整个设计的其他部分都使用 em 或者 rem 单位就可以了。 认真地选择最小和最大的字体大小。在这一点上，你需要决定是否直接使用视口单位，还是更精确控制缩放速率。如果选择后者，那么Sass或者 LESS 的 mixin 或者 PostCSS 插件会帮你省不少工作。 一开始就选择好最小和最大的字体大小。这是最重要的选择。因为其他所有组件的字体大小都依赖 root em。在项目后期修改 root em，意味着你必须调整所有的一切。 在使用流式技术之前别忘了声明的一个默认的字体大小。这个默认值会在不支持流式单位的浏览器上工作，它不用等于最小的字体大小。 最后，你还需要考虑设计稿的限制，以及如何处理如标题级别和行宽等事情。看看文章中提到的这些技术。如果你想让组件而不是标题以与常规文本不同的速率缩放，那在添加 calc() 表达式之前考虑可读性和样式表的维护。 希望你看完本文能有所启发，考虑下个项目是否适合使用流式字体布局。 必读 “Fit to Scale,” Trent Walton “Fluid Type,” Trent Walton “Viewport Sized Typography,” Chris Coyier 相关阅读 “Responsive Typography With SASS Maps,” Jonathan Suh “Benton Modern: A Case Study on Art-Directed Responsive Web Typography,” Marko Dugonjić “Advanced Web Typography: Responsive Web Typography,” Elliot Jay Stocks 扩展阅读 “Everything I Know About Responsive Web Typography,” Zell Liew “Responsive Typography With REMs: How to Build a Scalable Typographic Foundation in Three Steps,” Max Luster “Fluid Typography for Responsive Websites,” Ana Sampaio “Responsive Typography,” Responsivedesign.is 原文：Truly Fluid Typography With vh And vw Units 作者： Michael Riethmuller","tags":[{"name":"CSS","slug":"CSS","permalink":"http://zhouweicsu.github.io/blog/tags/CSS/"},{"name":"fluid","slug":"fluid","permalink":"http://zhouweicsu.github.io/blog/tags/fluid/"},{"name":"Typography","slug":"Typography","permalink":"http://zhouweicsu.github.io/blog/tags/Typography/"}]},{"title":"「译」哪些编程语言是函数式的？","date":"2016-03-09T16:00:00.000Z","path":"2016/03/10/which-programming-languages-are-functional/","text":"在本文的第一部分中，我没有从学术角度，也没有从营销角度，而是以一种搬砖码农能看懂的方式，解释了什么是函数式编程语言。更重要的是，我希望我对副作用的定义，能帮助搬砖码农更轻松地在应用程序失控前找到它们。 现在，让我们来看看现实世界的函数式编程语言吧… 编程领域盘点有了快速定位副作用的技能之后，我们可以查看一个指定函数并指出它的隐藏复杂体。有了函数式编程的定义之后，我们可以盘点一下编程领域，在每个方向上提出一些新观点… 函数式编程不是…它不是 map 和 reduce即使你知道函数式语言中都有这些函数，但它们并不是决定语言是函数式的关键。只不过每次在你试图从一系列处理中分离复杂性时，它们都意外地出现罢了。 它不是 λ 函数同样，你可能知道每一个 FP(函数式编程) 语言都推崇“函数是一等公民”。但它只是你创建一门避免副作用语言的自然产物。它是一个助推器，但不是根本原因。 它不是类型静态类型检测是一个非常有用的工具，但它不是 FP 的必备条件。Lisp 是最早的函数式编程语言，也是最早的动态语言。 不过静态类型非常有用。Haskell 在对抗副作用时非常优雅地使用了类型系统。但它们不是构成或破坏函数式语言的要素。 一直说，大声说，函数式编程就是讨论副作用。 （当然，也讨论副原因。） 这对于语言来说意味着什么？JavaScript 不是函数式编程语言函数式语言会帮你消除副作用，不能消除时会控制副作用。JavaScript 并不符合这条准则。实际上，很容易发现 JavaScript 许多推荐使用副作用的地方。 最明显的就是 this。这个隐含输入存在每一个函数里。特别不可思议的是 this 的含义改变的是那么任性。即使是 JavaScript 专家也会在定位 this 当前所指对象时遇到困难。从函数式的角度看，this 的神出鬼没应该算设计上的一个败笔。 但是你可以使用 JavaScript 的函数式编程库（例如，Immutable.js），它可以轻松将编程变成函数式风格，而不会改变语言的本质。 （顺便说一句，如果你喜欢这个 JavaScript 领域大受欢迎的 函数式库，那想象一下你会多喜欢一门完全支持函数式风格的语言。） Java 不是函数式编程语言Java 绝不是函数式编程语言。Java 1.8 版本加入的那些 λ 函数也不会改变这个事实。Java 是完全站在函数式编程的对立面。它的核心设计原则表明，代码应该以一系列副作用，也就是依赖同时又会改变对象本地状态的方法来实现。 事实上，Java 对函数式编程是不友好的。如果你写了一段无副作用的 Java 代码，这段代码不读取也不改变任何本地对象的状态，那你就是一个糟糕的 Java 程序员。因为 Java 代码不应该那么写啊。无副作用的代码将会处处都是 static 关键字，其他人看了之后会皱起眉头然后把你赶出去。 我不是说 Java 错了。（呃，好吧，我就是这个意思。）但关键是它对副作用的太对与 FP 完全不同。Java 认为局部副作用是优质代码的基石；而 FP 认为它们是魔鬼。 你可以从略微不同的角度看待这个事情。你可以把 Java 和 FP 看做解决副作用问题的两个不同答案。两种模式都认为副作用是个问题，只是解决方法不同。面向对象的解决方案是，“将它们包含在被称之为‘对象’的范围内”，而 FP 的解决方案是“消灭他们”。然而，在实践中 Java 并不仅仅试图封装副作用；还利用它们。如果你没有使用有状态的对象制造副作用，那你就是一个糟糕的 Java 程序员。经常写 static 的人实际上会被鱿鱼。 Scala 身负重任其实，Scala 是一个非常有挑战性的命题。如果它的目标是统一 OO 和 FP 这个两个世界，那么从副作用来看，我们认为它试图弥合“强制性副作用”与“禁止副作用”之间的鸿沟（对，此处我说的 OO 就是指 Java，在 Scala 这个上下文中，我认为把他们划上等号没有什么不妥。）。这么多相对的观点，我不能确定它们都能被化解。仅通过让对象支持 map 函数是绝对不能统一这两者的。你需要更深入和协调关于副作用的这两个对立立场之间的冲突。 Scala 是否成功协调留给你自己判断。但如果我负责推广 Scala，我会把它的卖点定位为从Java的副作用向纯粹FP的一个平滑过渡。与其统一他们，不如让它成为一条桥梁。事实上，许多人在实践中都是这么认为的。 ClojureClojure 对副作用的态度很有意思。它的开发者，Rich Hickey，说过 Clojure “80% 是函数式的”。我想我能解释为什么只有 80%。从一开始，Clojure 就被设计为解决一个特定类型的副作用： 时间。 举例说明，这里有个 Java 笑话： 5 加 2 等于多少？ 7。 答对了。 5 加 3 等于多少？ 8。 错。等于 10，因为上一步的 5 变成 7 了，还记得吗？ 好吧，这不是很好笑。但关键是，在 Java 中，值不会一成不变。我们可以把 5 赋给某个值，然后调用函数，你会发现那个值不再是 5 了。数学告诉我们 5 永远不可能改变——我们可以调用函数返回一个新值，但是我们不可能影响数字 5 的本质。而 Java 却说值一直在发生着变化，除非把它们放在某个对象里。 这个整数的例子可能看不出来什么，但遇到更大的值时影响也会被放大。还记得第一部分中 InboxQueue 的例子吗？ InboxQueue 的状态是一个随着时间变化的值。我们可以认为时间就是 InboxQueue 的一个副原因。 Clojure 一直恶狠狠地盯着时间的副原因。Rich Hickey 的观点（所有观点之一！）是，时间的隐含影响意味着我们无法依赖不变的输入值；如果我们不能依赖这个值，那我们也就不能依赖函数输入，结果就是我们无法依赖任何可预见的或重复的行为。如果连输入值都有副作用，那一切都会有副作用。如果输入值不是纯净的，那程序里的任何东西都不会纯净。 所以 Clojure 拿时间开刀了。它所有的值默认都是不可变的（随时间不可变）。如果你需要一个可变值，Clojure 提供对不可变值的包装器，这些包装器的使用都有着严格的限制： 必须使用包装器来改变值。 你不能不知不觉地创建一个可变值。你必须使用 guards 显式地标明潜在的副作用。 你也不会不知不觉地销毁一个可变值。你必须使用 guards 显式地告知副作用的风险。 当你打开一个可变值的包装器，你得到的依然是不可变值。这样就可以轻松摆脱依赖时间的环境，进入一个纯净的环境。 从时间的角度看，Clojure 是函数式编程语言一个极佳的例子。这个语言强烈敌视时间副作用。默认情况下它会消除副作用，但当你必须使用副作用时，它帮你牢牢的控制它，防止副作用污染其他的程序。 Haskell如果说 Clojure 只是敌视时间，那 Haskell 就是明显的敌意了。但 Haskell 真的也很讨厌副作用，且花费了大量努力来控制它们。 Haskell 与副作用斗争过程中的一个方式就是使用类型。它将所有的副作用都推进类型系统。例如，假设你有一个 getPerson 的函数。在 Haskell 中它看起来像这样： 1getPerson :: UUID -&gt; Database Person 你可以把它解读成，“在 Database 的上下文中，传入一个 UUID，返回一个 Person ”。这很有趣——你只需看一下 Haskell 函数的类型签名就可以确定包含了哪些副作用，没包含哪些副作用。你也可以做如下担保，“该函数不会访问文件系统，因为它没有申明那种类型的副作用。”严格控制（PureScript 进一步采取了这个思想，这也是值得研究）。 同样的，你可以看看如下函数： 1formatName :: Person -&gt; String …这个函数就是传入一个 Person，返回一个 String。没有别的了，因为如果存在副作用，你会看到它们被锁进了类型签名中。 但也许最有趣的是，下面这个例子： 1formatName :: Person -&gt; Database String 这个签名告诉我们，这个版本的 formatName 函数包含数据库相关的副作用。什么鬼？为什么 formatName 函数需要数据库？你的意思是我将需要初始化和模拟出一个数据库就为了测试一个名字格式器？这真的很奇怪。 仅仅通过函数签名，我就知道这个函数设计的有问题。我不需要查看代码，仅从概览就知道这个函数不对劲。多么神奇！ 简短地与 Java 的签名对比一下： 1public String formatName(Person person) &#123;..&#125; 这与哪个 Haskell 版本等价？如果不看函数体，你没有办法知道。它也许是个纯净版，也有可能会访问数据库，还有可能会删除文件系统然后返回，=“去你的老板！”=。Java 的类型签名里关于函数的功能信息和表面信息都很有限。 相反，Haskell 的类型签名则告诉了你很多关于函数设计的东西。又因为它们是由编译器检查，那它们告诉你的东西你能确定都是真的。这就意味着它们是个非常好的架构工具。它们能非常高效地暴露设计缺陷，它们也能暴露代码模式。我会在本文之外也会继续使用 “functor” 和 “monad”，但我依然认为高水准的软件设计模式首先得有高水准的需求分析，但当你有一个高水准的符号系统，那高水准的需求分析也会更容易（我有一些伟大的关于 Clojure 的设计讨论，在这些讨论中我们使用 Haskell 签名来解释我们自己，验证设计的一致性，并总结我们的结论。是的，你没听错，就是 Clojure 的讨论。Haskell 的符号系统具有远超语言本身的价值。）。 PerlPerl 在任何关于副作用的讨论中都值得被提及。因为它有个神奇的参数，$_，该参数是“上一个函数调用的返回值（查看 man perlvar 获取准确定义）。”它被许多核心函数库隐式地使用和/或改变。据我所知，这让 Perl 成为了唯一的将全局副作用当做核心特性的语言。 Python我们来快速浏览一下 Java 中一个基本的副作用模式：123public String getName() &#123; return this.name;&#125; 我们如何使这个调用纯净化？因为，this 是一个隐含输入，所以我们要做的就是将它作为一个参数输入：123public String getName(Person this) &#123; return this.name;&#125; 现在 getName 是一个纯函数。值得一提的是 Python 默认选择了第二种方式。在 Python 中，所有对象方法使用 this 作为第一个参数，按照惯例一般写成 self:12def getName(self): self.name 显式确实优于隐式。 数据模拟数据模拟框架一般来说会做两件事情。 第一件事就是帮你初始化输入对象。语言初始化复杂值时越困难，数据模拟越有用。但这不重要。 第二件事才是本次讨论的重点——通过测试给函数初始化正确的副原因，测试之后查看正确的副作用是否发生。 通过副作用的视角，数据模拟是代码不纯的一个标志，在函数式程序员的眼里，数据模拟就是证明某些事情是错误的。我们应该消除副作用，而不是去下载一些库来检查它的正确性。 一个铁杆 TDD/Java 兄弟曾经问我，在 Clojure 中如何模拟数据。答案是，我们不模拟。如果需要模拟数据，说明我们需要重构代码了。 设计缺陷如果我是小间谍（I-Spy）出一本关于副作用的书，那最容易找到的目标就是无参数输入的函数，与无返回值的函数。 没有参数意味着副原因无论何时你看到一个没有参数的函数，以下两个说法定有个对的：要么函数是总返回相同的值，要么函数的输入来自其他地方（函数有副原因）。 例如，下面这个函数必须始终返回一个相同的整数值（否则就有副原因）： 1public Int foo() &#123;&#125; 没有返回值意味着副作用无论何时你看到一个没有返回值的函数，那么这个函数要么有副作用，要么调用它就毫无意义： 1public void foo(...) &#123;...&#125; 根据函数签名，绝对没有理由去调用这个函数。因为它不会给你任何东西。唯一调用它的理由就是，它会悄悄地制造一些神奇的副作用。 概要/总结对副作用真正的，直观的认识，会改变你对写码的看法。会改变一切你对单独的函数，甚至整个系统架构的看法。会改变你评判编程语言，工具和编程技巧的方式。它会改变一切。从今开始消灭副作用… 原文链接：Which Programming Languages Are Functional? 译者：zhouweicsu","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zhouweicsu.github.io/blog/tags/JavaScript/"},{"name":"FP","slug":"FP","permalink":"http://zhouweicsu.github.io/blog/tags/FP/"},{"name":"Functional Programming","slug":"Functional-Programming","permalink":"http://zhouweicsu.github.io/blog/tags/Functional-Programming/"},{"name":"Clojure","slug":"Clojure","permalink":"http://zhouweicsu.github.io/blog/tags/Clojure/"},{"name":"Haskell","slug":"Haskell","permalink":"http://zhouweicsu.github.io/blog/tags/Haskell/"},{"name":"Python","slug":"Python","permalink":"http://zhouweicsu.github.io/blog/tags/Python/"},{"name":"Perl","slug":"Perl","permalink":"http://zhouweicsu.github.io/blog/tags/Perl/"}]},{"title":"「译」什么是函数式编程？","date":"2016-01-13T16:00:00.000Z","path":"2016/01/14/what-is-functional-programming/","text":"本文讲的是我认为的函数式编程到底是什么，这应该对于搬砖写码给别人打工一心只想快点把活干完的码农来说，应该是很合适的。 首先我告诉你，你写的每个函数都有两组输入和两组输出。 两个？只有一个吧，你确定？ 是的，两个。绝对是两个。我们来看看第一个例子： 12345public int square(int x) &#123; return x * x;&#125;// 注意：其实什么语言无所谓，但为了强调，我选择了一个有明确的输入输出类型的语言。 上面的例子中，通常你认为输入就是int x，输出也是int。 但这只是输入输出的第一个集合。如果你想叫它传统集合也可以。下面我们看看第二组输入输出集合的例子： 1234567public void processNext() &#123; Message message = InboxQueue.popMessage(); if (message != null) &#123; process(message); &#125;&#125; 从语法上看，这个函数既没有输入也没有输出，然而很明显它依赖着什么，并且很显然也在做着什么。事实是，它有一个隐含的输入输出集合。这个隐含的输入是popMessage()函数调用之前IndexQueue的状态，隐含的输出是process产生的任何结果，再加上函数运行之后InboxQueue的状态。 毫无疑问 —— IndexQueue的状态是这个函数真正的输入。如果不知道这个值，那processNext的行为不可预测。并且它也是真正的输出 —— 如果不考虑IndexQueue的新状态，那调用 processNext之后的结果也不能被完全理解。 所以第二段代码有隐含的输入和输出。它依赖一些外部输入，也会产生一些结果，但是如果你只看 API，那你永远猜不对它在干什么。 这些隐含的输入和输出有一个正式的名字：“副作用[side-effects]”。副作用有很多类型，但它们本质都一样：“当我们调用函数时，它需要的什么东西不在参数列表中，它的返回值里体现不出它做过什么事情。” （实际上我认为我们需要两个概念：隐含输出的“副作用[side-effects]”，和隐含输入的“副原因[side-causes]”。为了简便，接下来本文会使用“副作用”，但我绝对也在讨论副原因。我在讨论所有的隐含输入和输出。） 副作用是水下面的冰山当函数有副作用（和副原因）时，函数看起来像这样： 1public boolean processMessage(Channel channel) &#123;...&#125; …如果你自以为知道它在干什么，那就大错特错了。如果不看内部代码，你根本就不知道它需要什么，它会产生什么结果。它会从 channel（通道）中取得一段消息然后处理它吗？可能。如果某个条件为真它会关闭 channel 吗？也许。它会在数据库的某处更新一个数值吗？或许会。如果找不到它期望的日志存储路径它会崩溃吗？可能会。 副作用是复杂的冰山。你看着函数签名与名字，认为知道这个函数在干嘛。但隐含在函数签名的表面之下的，有可能是其他任何操作。任何隐含的依赖，任何隐含的改变。不看具体的实现代码，你不会知道它到底涉及了哪些操作。API 的表面之下又是另一个潜在的巨大复杂体。如果想要掌控它，你只有三个选择：选择一，深入了解函数定义，将里面的复杂体暴露出来；选择二，忽略它，然后祈求出现最好的结果；选择三，选择二通常是个严重的错误。 难道这不就是所谓的封装吗？不是。 封装是隐藏实现细节。隐藏调用者不需要关心的内部代码。封装是个好的设计原则，但跟我们刚才说的隐含的东西不是一回事。 副作用并不是“隐藏实现细节”——而是隐藏了与函数外部环境相关的代码。一个有副原因的函数，会有许多找不到说明的外部依赖。一个有副作用的函数，不会告诉你它可能会改变哪些外部因素。 副作用不好吗？当它们完全按照最初程序员的预期那样工作，就不是不好的，他们可能会正常工作。但这有个前提：我们必须相信最初程序员的隐含期望值是完全正确的，并且随着时间的推移依然正确。 我们有没有按照这个函数当初编写时希望的那样正确地初始化环境状态呢？又或者这个环境有没有在某个地方已经改变了吗？也许因为一小段看似无关的代码的改变。又或者我们把它安装在了一个新环境中。对于环境状态的隐含假设，意味着我们默认了使环境如此运行的希望。 我们能测试这些代码吗？答案是无法单独测试。这不像电路板，我们不能简单的给出输入然后检查输出。我们得打开代码，找出它隐含的依赖与影响，然后模拟它本该存在的外部环境。我已经见识过好几个TDD’ers（测试驱动开发者）在黑盒还是白盒测试的选择之间团团转了。正确的做法是，你应该做黑盒测试——忽略具体的实现细节——但是如果你允许副作用的存在，那就不能做黑盒测试了。副作用对黑盒彻底的关上了大门，因为如果不打开盒子看看里面的代码，你都不知道输入和输出是什么。 这个影响在调试的时候会更复杂。如果函数不允许副作用（或副原因），那你可以通过给出特定输入然后检查输出结果，轻松判断函数是否正常工作。但如果函数有副作用呢？那你必须考虑多少系统的其他部分就不好说了。尤其是当函数什么都可以依赖，什么结果都可能出现的情况下，那任何地方都可能有 bug。 让副作用浮出水面对于这个复杂体我们能做些什么吗？当然可以。实际上步骤相当简单：把函数的依赖变成输入，声明函数的返回并将它当做输出。就是这么简单。 我们写个例子试一下。下面有个隐含输入的函数。快速找出它你就能得到额外奖励： 12345public Program getCurrentProgram(TVGuide guide, int channel) &#123; Schedule schedule = guide.getSchedule(channel); Program current = schedule.programAt(new Date()); return current;&#125; 这个函数的隐含输入就是当前时间（new Date()）。我们只需将这个时间当做一个参数输入就能将这个复杂的问题解决： 12345public Program getProgramAt(TVGuide guide, int channel, Date when) &#123; Schedule schedule = guide.getSchedule(channel); Program program = schedule.programAt(when); return program;&#125; 函数现在没有隐含的输入（和输出）。 我们来对比一下这个新版本的优劣： 缺点看起来似乎更复杂了。本来是2个参数，现在变成了3个。 优点函数并没有变复杂。隐含一个依赖并没有使之变得更简单，实事求是地写出来也并没有使之变得更复杂。 它让测试变得无比简单。测试一天的不同时间，时钟的变换，闰年等等，都很明确，因为可以传入任何想要的时间值。我在产品中见过加参数之前的代码版本，还有为了测试方便对系统时钟的各种欺骗。想象一下，多写一参数可以省多大事啊！ 很容易得到一个结论：现在函数仅仅是描述输入与输出之间的一种关系。如果你知道输入是什么，你就应该知道结果是什么，你对函数产生的结果了如指掌。这个意义重大。现在可以独立测试代码了。我们只需测试输入与输出之间的关系，就可完成整个函数的测试了。 （另一方面，它也很有用。我们利用这个函数，还可以知道“一个小时之后会播放什么节目”。） 什么是“纯函数”？此处应该有掌声。 终于，在清楚地知道隐含输入与输出之后，我们现在可以给出“一个搬砖码农对纯函数的定义”： 一个函数能称之为“纯”函数，则该函数所有的输入都是显示的（无隐含输入），同样它的所有输出都是显示输出。 相反，若函数有隐含输入或输出，那它就是“不纯”的，而函数给我们的协议并不完整。复杂的冰山隐隐可见。我们绝不能“单独”使用不纯的代码。我们也绝不能单独测试这些代码。因为它总是依赖别的东西，无论什么时候测试或调试，都要考虑这些依赖。 什么是“函数式编程”？在了解纯函数与不纯函数之后，我们可以给出“一个搬砖码农对函数式编程的定义”： 函数式编程就是编写纯函数，尽可能移除隐含的输入与输出，这样我们的代码就是仅描述输入与输出之间关系的代码。 我们接受有些副作用是不可避免的——因为许多程序就是为了执行某些操作而不是获取返回值，但在我们的程序里，我们将严格控制它。我们会尽我们所能消除副作用（和副原因），当不能消除时，我们会严格控制。 或者换一种说法：不要隐式地包含任何一段代码需要的任何东西，也不要隐藏它将会产生的任何结果。如果代码需要某些东西才能正确执行，就让它成为输入参数。如果函数做了什么有用的事情，声明它让它成为输出。当我们这么做了之后，我们的代码将会非常清晰。复杂体将会浮出水面，那时我们就能消除或者处理它。 什么是“函数式编程语言”？每一种语言都支持纯函数——很难使得add(x,y)不纯（对 Java 来说，还是很难）。许多情况下，我们只需要将所有的输入和输出提升到函数签名中，就能将一个不纯的函数转换为纯函数，这样签名就能完整描述该函数的行为。那所有的编程语言都是“函数式”吗？ 当然不是。如果是那个词不就毫无意义了。 那我们能给出的“搬砖码农对函数式编程语言的定义”是什么呢？ 函数式编程语言就是支持和鼓励不使用副作用来编程的语言。 更确切的说法：函数式语言会尽可能帮你消除副作用，当不能消除时就严格控制。 更生动的说法：函数式语言非常仇视副作用。副作用是复杂体，复杂体是 bug，bug 就是魔鬼。函数式语言也会帮助你仇视副作用。你们一起就能把副作用整得服服帖帖。 就这样？对，就这样。有些细微之处——你之前也许永远都不会认为这是一个隐藏输入的事情，但这个是关键。构建软件之前，带上“副作用是头等敌人”的看法，它会改变你对编程的一切认知。戳我查看第二篇文章，在对副作用，函数式编程有初步了解之后，拿出机关枪向编程领域开一梭子，看看能打到谁。 致谢本文是对函数式编程本质的一系列讨论的总结。特别是与 Sleepyfox 关于“如果使用正确的库，JavaScript 是否可以被认为是函数式编程语言”的讨论。我的直觉当然不是，但通过思考“为什么”，我走向了一条非常有价值的思考链。 跟 James Henderson 打个招呼，他今年跟我灌输了许多很有价值的函数式思想。 感谢 Malcolm Sparks, Ivan Uemlianin, Joel Clermont, Katy Moe 和我的影分身 Chris Jenkins 对本文的校对与指导。 原文：What Is Functional Programming? 译者：zhouweicsu","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zhouweicsu.github.io/blog/tags/JavaScript/"},{"name":"FP","slug":"FP","permalink":"http://zhouweicsu.github.io/blog/tags/FP/"},{"name":"Functional Programming","slug":"Functional-Programming","permalink":"http://zhouweicsu.github.io/blog/tags/Functional-Programming/"}]},{"title":"「译」2015 年度 JavaScript 开发者调查结果","date":"2015-12-16T16:00:00.000Z","path":"2015/12/17/javascript-developer-survey-results/","text":"年关将至，JavaScript 开发者问卷调查也已经结束了。本次调查收到了超出我想象的回复，我也很高兴与你们分享调查结果。 截至目前，有超过 5000 人参与了问卷调查，准确的说是 5350 人，我真的迫不及待想与大家分享详细这次调查的细节。分享之前先感谢参与调查的每一个人。这是一个 JavaScript 社区的伟大时刻，我真的对未来的事情感到无比激动。 我没有想到大家这么积极，下次我一定会对表单做一些改进。下次我会先将调查问卷放在 GitHub 上，这样在调查开始前，社区有一两个星期的时间来收集问题和选项。这样，我就可以得到更准确地结果，也可以避免出现“你竟然没有包含Emacs！”这样的抱怨。 现在，基于调查结果。我将保持中立的给大家分析结果，这样大家就可以得出自己的无偏见结论。 1、你写什么类型的 JavaScript？有高达 97.4% 的受访者用 JavaScript 写 web 浏览器端程序，其中有 37% 写移动端 Web 应用。超过 3000 人（56.6%）也使用 JavaScript 写服务端。在这些参与调查的人中间，有 5.5% 的人还在一些嵌入式环境中使用 JavaScript，例如 Tessel 或 Raspberry Pi（树莓派）。 少数受访者反馈他们还在其他地方使用了 JavaScript，主要有 CLI 和桌面应用的开发。还有少数提到了 Pebble 和 Apple TV。这些都归类在其他选项中，占总票数的 2.2%。 2、你在哪使用 JavaScript？不出所料，94.9% 的投票者在工作中使用 JavaScript。但是，也有 82.3% 的投票者在其他项目中使用。其他回复包括教学，好玩，和非盈利目的使用。 3、你写 JavaScript 多长时间了？超过 33% 的受访者有超过 6 年 JavaScript 代码的编程经验。除了这些，还有 5.2% 的人 1 年前开始写JavaScript，12.4% 的人是 2 年前，15.1% 的人是 3 年前。这说明在 5350 个投票者中有 32.7% 的人是近几年才开始写 JavaScript 的。 4、如果可以的话，你会使用以下哪种 compile-to-JavaScript 语言？有高达 85% 的受访者表示他们将使用 ES6 编译成 ES5。同时依然有 15% 的人用 CoffeeScript，15.2% 的人用 TypeScript，只有区区 1.1% 的人在使用 Dart。 这是我想进一步探讨的问题之一，因为有 13% 的人选择了“其他”。选择其他的绝大部分答案是 ClojureScript，eml，Flow，和 JSX。 5、你会选择以下哪种 JavaScript 编程风格？绝大多数（79.9%）的 JavaScript 开发者在这个问题上选择分号。相反，11% 的开发者选择不使用分号。逗号方面，44.9% 的开发者选择将逗号放在表达式末尾，然而有 4.9% 的开发者喜欢先写逗号。缩进方面，65.5% 的开发者喜欢空格，另外 29.1% 的则更喜欢制表符。 6、你使用以下哪些 ES5 特性？79.2% 的受访者都使用过数组功能函数，76.3% 的开发者使用严格模式，30% 的开发者选择了 Object.creat，而仅有 28% 的开发者选择 getters 和 setters。 7、你使用以下哪些 ES6 特性？值得指出的是，投票表明箭头函数是使用最多的 ES6 特性，有 79.6%。Let 和 const 加一起一起有77.8% 的得票率，promises 也有 74.4% 的开发者选择。不出所料，仅有 4% 的参与者使用过 proxies。仅有 13.1% 的用户表示他们使用 symbols，同时有超过 30% 的人使用 iterators。 8、你写测试吗？有 21.7% 的开发者从不写任何测试，大部分人偶尔写测试，34.8% 的人经常写测试。 9、你运行持续集成测试吗？与 CI 类似，许多人不使用 CI 服务器（超过40%）。但 60% 的受访者有时候会使用 CI，有 32% 的人在 CI 服务器上跑测试。 10、你怎么测试？59% 的人喜欢使用 PhantomJS 或类似工具运行自动化浏览器测试，51.3% 的人还在 Web 浏览器上手动测试。有 53.6% 的人会在服务端进行自动化测试。 11、你使用过以下哪个单元测试库？似乎大部分投票者选择的不是 Mocha 就是 Jasmine 来运行 JavaScript 测试用例，Tape 有 9.8% 的投票。 12、你使用过以下哪个代码质量检测工具？似乎受访者在这个问题上被分为 ESLint 派和 JSHint 派，但是 JSLint 还有几乎 30% 的人支持，这么多年依然坚挺很是令人惊奇。 13、你是如何处理客户端依赖问题？npm 接管了客户端依赖管理系统的天下，60% 的支持率就是证据。Bower 依然有 20% 的观众，而普通的老式 &lt;script&gt; 下载和插入则获得了 13.7% 的选票。 14、你首选的脚本构建方案是什么？构建工具的选择很分散，部分原因应该是我们有太多选择。Gulp 最流行，有超过 40% 的选票。紧接着是 27.8% 的 npm run，Grunt 有 18.5% 的支持者。 15、你首选的 JavaScript 模块加载工具是什么？目前，似乎大部分开发者都在 Browserify 和 Webpack 之间徘徊，而后者高出 7 个百分点。29% 的用户表示他们在选择前面两个提到的工具打包模块之前，会先使用 Babel。 16、你使用以下哪些库？现在回想起来，这是个得益于协同编辑的问题之一。jQuery 得到了超过 50% 的支持，表现依然强势。Lodash 与 Underscore 在参与投票的 JavaScript 使用者中也占据显著地位，XHR 微型库仅获得了 8% 的票数。 17、你使用以下哪些框架？React 和 Angular 的遥遥领先并不令人奇怪。有 22.8% 得票的 Backbone 依然处于安全位置。 18、你使用 ES6 吗。。。这个问题的答案比较分散，有近 20% 的人几乎从不使用 ES6，超过 10% 的人只写 ES6，近 30% 的人广泛使用，近 40% 的人经常使用。 19、你知道 ES2016 会有什么特性吗？大致说来，有一半的投票者不知道 ES2016 将会有什么特性，另外一半对新特性有所了解。 20、你了解 ES6 吗？超过 60% 的受访者了解基本的概念，10% 的人完全不了解 ES6，有超过 25% 的人认为他们对 ES6 非常了解。 21、你认为 ES6 是一个进步吗？几乎有 95% 的受访者认为 ES6 是 JavaScript 的一个进步。下次碰到 TC39 的会员我得祝贺他们！ 22、你首选的编辑器是什么？又一次，因为选择太多导致答案很分散。超过一半的受访者喜欢 Sublime Text，超过 30% 的人喜欢用 Atom 和它的开源克隆版。超过 25% 的票投给了 WebStorm，vi/vim 也有超过 25% 的得票率。 23、你首选的开发操作系统是什么？ Mac 有超过 60% 的投票者使用，Linux 和 Windows 的用户都接近 20%。 24、你如何搜索可重用代码，库和工具？受访者最喜欢 Github 和搜索引擎，但通过博客，Twitter 和 npm 网站搜索也占了很大一部分。 25、你参加 JavaScript 社会活动吗？有近 60% 的人至少参加过一次会议，74% 的人表示他们喜欢参加聚会。 26、你的 JavaScript 应用支持哪些浏览器？相当分散的答案，但还好大部分受访者不再考虑 IE6 的使用者了。 27、你会定期了解 JavaScript 的最新特性吗？有大概 80% 的受访者会实时了解最新的 JavaScript 特性。 28、你在哪了解最新的 JavaScript 特性？不出所料，Mozilla 开发者网络在文档和新闻方面处于领先地位。JavaScript 周刊也是一个非常受欢迎的新闻和文章的直接来源，有超过 40% 的支持率。 29、你听说过以下哪些特性？超过 85% 的投票者听说过 ServiceWorker，但我很想知道这些人有没有使用它！ 30、除了 JavaScript，你还主要使用哪些语言？有太多的语言可供选择，我肯定会漏那么几个，但结果不言自明。 谢谢！ 最后，感谢每一位参与这次调查的人。本次问卷调查受到了超出我预期的欢迎，期待明年再进行一次类似的调查。我希望，那会是一个更多样性，也许再少一点偏见的调查。 这次问卷调查你获得了什么？ 作者：Nicolás Bevacqua，时间：2015-12-11 原文链接: https://ponyfoo.com/articles/javascript-developer-survey-results 译者：zhouweicsu","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zhouweicsu.github.io/blog/tags/JavaScript/"},{"name":"调查","slug":"调查","permalink":"http://zhouweicsu.github.io/blog/tags/调查/"}]},{"title":"「译」ECMAScript 2016 (ES7) 新特性一览","date":"2015-12-03T16:00:00.000Z","path":"2015/12/04/tc39-process/","text":"本文回答了关于下一版 JavaScript（ECMAScript 2016）的以下几个问题： 谁在设计？ 如何设计？ 会有什么特性？ 本文会持续更新以及时反馈最新进展。 1、谁在设计 ECMAScript？答：TC39 (Technical Committee 39)。 TC39 是推进 JavaScript 发展的委员会。其会员都是公司（其中主要是浏览器厂商）。TC39 定期召开会议，会议由会员公司的代表与特邀专家出席。会议纪录都可在网上查看，可以让你对 TC39 如何工作有一个清晰的概念。 有时候（实际上本文就如此），你会发现 TC39 会员这个词被用来指代一个人，其实指的是 TC39 会员公司派出的代表。 很有意思的是，TC39 实行的是协商一致的原则：通过一项决议必须得到每一位会员（公司代表）的赞成。 2、如何设计 ECMAScript？2.1 问题：ECMAScript 2015 (ES6) 这个版本太大了最近发布的 ECMAScript（ES6）新增内容很多，在 ES5 发布近 6 年（2009-11 至 2015-6）之后才将其标准化。两个发布版本之间时间跨度如此之大主要有两大原因： 比新版率先完成的特性，必须等待新版的完成才能发布。 那些需要花长时间完成的特性，也顶着很大的压力被纳入这一版本，因为如果推迟到下一版本发布意味着又要等很久，这种特性也会推迟新的发布版本。 因此，从 ECMAScript 2016（ES7）开始，版本发布将会变得更加频繁，每年发布一个新版本，这么一来新增内容也会更小。新版本将会包含每年截止时间之前完成的所有特性。 2.2 解决方案： TC39 设计过程每个 ECMAScript 特性的建议将会从阶段 0 开始， 然后经过下列几个成熟阶段。其中从一个阶段到下一个阶段必须经过 TC39 的批准。 阶段 0： Strawman 初稿什么是 Strawman？一个推进 ECMAScript 发展的自由形式的想法。该想法必须由 TC39 的会员提交，如果是非会员则必须注册成为 TC39 贡献者才能提交。 必备条件：文件必须在 TC39 的会议上通过审议（原文），然后才能加入阶段 0 的建议页面。 阶段 1：Proposal 建议什么是 Proposal？一份新特性的正式建议文档。 必备条件：必须确定一位带头人来为负责这份建议。无论是带头人或者联合带头人都必须是 TC39 的会员（原文）。建议要解决的问题必须以简明的文字描述，而解决方案则要给出相应的实例和 API，并详细描述语义及算法。最后，必须指明此建议的潜在问题，例如与其他特性之间的关联，实现难点等。实现方式，polyfills 和 demo 也是需要的。 下一步：通过一个阶段 1 的建议，表明 TC39 愿意研究、讨论并促成该建议。接下来，我们就可以期待该建议的重大改变了。 阶段 2：Draft 草案什么是 Draft？草案是规范的第一个版本。其与最终标准中包含的特性不会有太大差别。 必备条件：建议此时必须要附加该特性的语法和语义的正式说明（使用 ECMAScript 标准的形式语言）。说明应该尽可能完善，但可以包含待办事项和占位符。该特性需要两个实验性的实现，其中一个可以在类似 Babel 的转译器（transpiler）中实现。 下一步：从该阶段开始只接受增量调整。 阶段 3：Candidate 候选什么是 Candidate？候选阶段，建议基本完成，此时将从实现过程和用户使用两方面获取反馈来进一步完善建议。 必备条件：规范文档必须是完整的。指定的评审人（由 TC39 而不是带头人指定）和 ECMAScript 规范的编辑须在规范上签字。还有至少要两个符合规范的实现（不必指定默认实现）。 下一步：此后，只有在实现和使用过程中出现了重大问题才会修改建议。 阶段 4：Finished 完成什么是 Finished？建议已经准备就绪，可以添加到标准之中。 必备条件：建议进入完成阶段之前需要满足以下几点： Test 262 的验收测试（基本上都是 JavaScript 写的用来验证语言特性的单元测试）。 两个通过测试的符合规范的实现。 特性实现相关的重要实践经验。 ECMAScript 规范的编辑在规范文本上的签字。 下一步： 建议将会尽快加入 ECMAScript 规范之中。当规范通过年度审核成为标准，该建议也正式成为标准的一部分。 3、别把它们称做 ECMASript 20xx 特性综上所述，只有建议进入阶段 4，你才能确定这个特性会被纳入标准之中。因为此时它很有可能被加入到下一版本的 ECMAScript，但也不是 100% 确定（因为有可能会花更长时间）。因此，你不能称这个建议为“ES7 特性”或“ES2016 特性”。所以我喜欢把文章或博客的标题写成这样： “ECMAScript 建议：某特性”。在文章开头说明建议所处的阶段。 “ES.阶段 2：某特性”。 如果建议处于阶段 4，我觉得称它 ES20xx 特性是 OK 的，但还是等规范的编辑确认该特性将会加入哪个版本之后才最保险。例如 Object.observe 就是一个已经进入阶段 2 ，却最终被撤回的 ECMAScript 建议。 4、ECMAScript 2016 将会有什么特性？已被纳入 ES2016 的特性： Array.prototype.includes (Domenic Denicola, Rick Waldron) 以下处于阶段 4 的特性将可能会纳入 ES2016： （暂时没有。） 以下处于阶段 3 的特性也许会纳入 ES2016： 指数运算符（Rick Waldron） SIMD.JS – SIMD APIs + polyfill（John McCutchan, Peter Jensen, Dan Gohman, Daniel Ehrenberg） 异步函数（Brian Terlson） Object.values/Object.entries（Jordan Harband） 字符串填充（Jordan Harband &amp; Rick Waldron） 函数参数列表与调用中的尾逗号（Jeff Morrison） 如果你不知道某个建议特性处于哪个阶段，你可以在 ECMA-262 GitHub 库的 readme 中查阅。 5、Array.prototype.includes (Domenic Denicola, Rick Waldron)数组的 includes 方法有如下签名：1Array.prototype.includes（value：任意值）： boolean 如果传入的值在当前数组（this）中则返回 true，否则返回 false：1234&gt; ['a', 'b', 'c'].includes('a')true&gt; ['a', 'b', 'c'].includes('d')false includes 方法与 indexOf 方法很相似——下面两个表达式是等价的：12arr.includes(x)arr.indexOf(x) &gt;= 0 唯一的区别是 includes() 方法能找到 NaN，而 indexOf() 不行：1234&gt; [NaN].includes(NaN)true&gt; [NaN].indexOf(NaN)-1 includes 不会区分 +0 和 -0 （这也与其他 JavaScript 特性表现一致）：12&gt; [-0].includes(+0)true 类型数组也有 includes() 方法： Typed Arrays will also have a method includes():12let tarr = Uint8Array.of(12, 5, 3);console.log(tarr.includes(5)); // true 5.1 常见问题 为什么方法取名 includes 而不是 contains？后者是最初的选择，但在 web 上将会破坏已有的代码（MooTools 在 Array.prototype 上添加了 contains 方法）。 为什么方法取名 includes 而不是 has？has 通常用于键（Map.prototype.has），includes 通常用于元素（String.prototype.includes）。集合中的元素既可以被看当做 键 也可被当做 值，所以才有 Set.prototype.has （而不是 includes）。 ES6 的 String.prototype.includes 方法可用于字符串，而不能用于字符。这是否和 Array.prototype.includes 不一致？如果数组和字符串的 includes 方法是相同的工作机制，那么数组的 includes 方法就应该接受数组，而不是数组元素了。不过这两个 includes 方法都参考了 indexOf 方法；字符一般是特殊情况，而任意长度的字符串则更常见。 5.2 扩展阅读 Array.prototype.includes (Domenic Denicola, Rick Waldron) 6、指数运算符（Rick Waldron）新提出来的特性是将 ** 作为指数操作的中缀运算符：1x ** y 与以下表达式运算结果相同：1Math.pow(x, y) 示例：12345let squared = 3 ** 2; // 9 let num = 3;num **= 2;console.log(num); // 9 扩展阅读： 指数运算符 (Rick Waldron) 7、SIMD.JS – SIMD APIs + polyfill (John McCutchan, Peter Jensen, Dan Gohman, Daniel Ehrenberg)SIMD 意思是“single instruction, multiple data（单指令流多数据流）”，CPU 可以通过单条指令操作一组数据（而不是仅操作单一值），SIMD 指令集最有名的一个例子就是由 Intel 处理器的 SSE（Streaming SIMD Extensions）。 下面是简短的示例代码，请参考后面源码获取更多信息。 123var a = SIMD.float32x4(1.0, 2.0, 3.0, 4.0);var b = SIMD.float32x4(5.0, 6.0, 7.0, 8.0);var c = SIMD.float32x4.add(a,b); 扩展阅读： SIMD.JS – SIMD APIs + polyfill (John McCutchan, Peter Jensen, Dan Gohman, Daniel Ehrenberg) JavaScript 可支持 SIMD (2ality) 8、异步函数（Brian Terlson）在我介绍异步函数之前，我会先介绍如何通过 Promises 和 generators 来使用看起来同步的代码去执行异步操作。 8.1 用 Promises 和 generators 编写异步代码对于需要异步地计算一次性结果的函数来说，Promises（ES6 的一部分）现在越来越流行。一个例子就是客户端 fetch API，它是一种替代 XMLHttpRequest 检索文件的方案。代码如下： 123456789101112function fetchJson(url) &#123; return fetch(url) .then(request =&gt; request.text()) .then(text =&gt; &#123; return JSON.parse(text); &#125;) .catch(error =&gt; &#123; console.log(`ERROR: $&#123;error.stack&#125;`); &#125;);&#125;fetchJson('http://example.com/some_file.json').then(obj =&gt; console.log(obj)); co 是一个使用了 Promises 和 generators 让编程风格看起来更像异步的库，但也需要使用类似于前一个例子的风格去编码： 12345678910const fetchJson = co(function* () &#123; try &#123; let request = yield fetch(url); let text = yield request.text(); return JSON.parse(text); &#125; catch (error) &#123; console.log(`ERROR: $&#123;error.stack&#125;`); &#125;&#125;); 每次回调函数（一个 generator 函数！）产生一个 Promise 给 co，回调函数就会被挂起。一旦这个 Promise 完成，co 就会恢复该回调函数：如果 Promise 被实现，yield 会返回这个实现的值，如果被拒绝，则 yield 会抛出异常。另外，co 能处理回调函数返回的结果（与 then() 相似）。 8.2 异步函数异步函数的语法基本上可以说是实现了 co 所做的： 12345678910async function fetchJson(url) &#123; try &#123; let request = await fetch(url); let text = await request.text(); return JSON.parse(text); &#125; catch (error) &#123; console.log(`ERROR: $&#123;error.stack&#125;`); &#125;&#125; 在内部，异步函数的工作非常类似于 generators，但它并不会被翻译为 generator 函数。 8.3 变体异步函数有以下几种变体： 函数声明： async function foo() { }函数表达式：const foo = async function () {};方法定义：let obj = { async foo() {} }箭头函数：const foo = async () =&gt; {} 8.4.扩展阅读 异步函数 (Brian Terlson) 通过 generators 简化异步计算 (“探索 ES6”章节) 9、扩展阅读下面是本篇博客的重要参考资料： ecma262（ECMA-262 是 ECMAScript 标准的一个ID）GitHub 库，它包括： 所有处于阶段 1 及以上阶段建议的 readme 文件。 处于阶段 0 的建议列表。 ECMA-262 的常见问题。 TC39 的进度文档 其他资料： Kangax 的 ES7 兼容性表格 会告诉你哪些建议在哪些浏览器中已经得到支持，并将建议根据所处阶段进行了分类。 更多关于 ES6 设计过程的信息： “ECMAScript 6 是如何被设计出来的”———“探索 ES6”中的章节。 作者：Dr. Axel Rauschmayer，时间：2015-11-15 原文链接: http://www.2ality.com/2015/11/tc39-process.html 译者：zhouweicsu","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zhouweicsu.github.io/blog/tags/JavaScript/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"http://zhouweicsu.github.io/blog/tags/ECMAScript/"},{"name":"ES7","slug":"ES7","permalink":"http://zhouweicsu.github.io/blog/tags/ES7/"},{"name":"ES 2016","slug":"ES-2016","permalink":"http://zhouweicsu.github.io/blog/tags/ES-2016/"},{"name":"TC39","slug":"TC39","permalink":"http://zhouweicsu.github.io/blog/tags/TC39/"},{"name":"设计过程","slug":"设计过程","permalink":"http://zhouweicsu.github.io/blog/tags/设计过程/"}]},{"title":"「译」别再丢用户与应用程序的状态了，赶紧用 Page Visibility 吧","date":"2015-11-23T16:00:00.000Z","path":"2015/11/24/dont-lose-user-and-app-state-use-page-visibility/","text":"优秀的应用从不丢失用户的进度与应用程序状态。而是在不中断用户的情况下自动保存相关数据，然后在必要的时候（例如：从后台状态或者意外关机中回来）恢复这些数据。 不幸的是，许多 Web 应用因为没考虑移动端的生命周期从而导致了这个错误：它们错误地监听了也许永远不会被触发的事件，或者完全忽略这个问题从而导致代价高昂的极差用户体验。不过公平地说，Web 平台提供的诸多不同的事件（visibilityState、 pageshow、 pagehide、 beforeunload、 unload）也使问题变得复杂。我们到底应该使用哪个事件，什么时候用？ 你在移动平台不能依赖 pagehide、 beforeunload、 和 unload 事件。因为也许在你喜欢的浏览器中使用没有 bug，但应用程序得运行在所有的移动操作系统中。活动的应用程序可以通过不同的方式进入到“后台状态”： 用户点击了一个通知，切换到另一个应用。 用户唤起了任务切换栏，去了另一个应用。 用户摁了 home 键去了首屏。 操作系统切换应用，例如，来了个电话。 应用程序一旦被切换到后台，随时可能被干掉。例如，操作系统会终止该进程以回收系统资源，用户也可以在任务切换栏中将它清除。因此，你应该认为触发 pagehide、 beforeunload、 和 unload 事件的“正常关闭”就是个例外。 为了提供可靠流畅的用户体验，无论是在 PC 端还是移动端，应用程序必须使用 Page Visibility API，根据 visibilityChange 状态的变化保存或恢复当前会话。这是应用程序唯一可以依赖的事件。 1234567891011// query current page visibility state: prerender, visible, hiddenvar pageVisibility = document.visibilityState;// subscribe to visibility change eventsdocument.addEventListener('visibilitychange', function() &#123; // fires when user switches tabs, apps, goes to homescreen, etc. if (document.visibilityState == 'hidden') &#123; ... &#125; // fires when app transitions from prerender, user returns to the app / tab. if (document.visibilityState == 'visible') &#123; ... &#125;&#125;); 如果你使用 unload 事件来保存状态，记录和报告分析数据，并执行其他相关逻辑，那你将会丢失大部分移动端会话数据，因为很多 unload 事件不会被触发。同样，如果你依赖 beforeunload 事件来提示用户没保存数据，那你忘记了刚才说的“正常关闭”就是一个意外。 使用 Page Visibility API，忘记其他事件，就当它们都不存在。将每次应用程序切换到 visible 都当做一个新的会话：恢复之前的状态，重置你的分析状态等等。然后，当应用程序切换至 hidden 时结束该会话：保存用户与应用程序状态，标记你的分析数据，以及做好所有其他必要的工作。 如果有必要，你可以做一些额外的工作，将这些基于可见性的会话都汇聚到记录应用程序与标签切换的用户流中，例如，给服务器汇报每一个会话，在服务器端将多个会话合并在一起。 实际实现中的问题长期来说，你只要 Page Visibility API 就够了。但现在你必须得与另一个事件 ———— pagehide 一起用，目的是为了考虑“页面要被卸载了”的情况。下表记录了当前每个浏览器下哪个操作会触发哪个事件的详细数据（基于我的手动测试）。 visibilityChange 可靠反映移动端任务切换。 beforeunload 价值有限，只能在 PC 浏览器上被触发。 unload 在移动端和 PC 端的 Safari 中都不会被触发。 可喜的是 Page Visibility 依赖覆盖了所有平台和浏览器厂商的任务切换场景。但是，到现在为止 Firefox 是唯一一个在页面 unloaded 的时候还会触发 visibilityChange 事件的浏览器，这里是Chrome、 WebKit、 Edge 有关这个问题的 bug。只要这些 bug 被修复，visibilityState 将是提高用户体验唯一需要的事件了。","tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://zhouweicsu.github.io/blog/tags/HTML5/"},{"name":"Page Visibility","slug":"Page-Visibility","permalink":"http://zhouweicsu.github.io/blog/tags/Page-Visibility/"}]},{"title":"「译」用 Browserify， Babel & hot reloading 快速构建 ES2015 工程","date":"2015-10-14T16:00:00.000Z","path":"2015/10/15/quick-es2015-project-setup-with-browserify-babel-hot-reloading/","text":"现在有很多 ES2015 和 React 工程的新手工具包。如果你想快速构建一个原型或者你只是想玩一玩代码，那你肯定希望配置越少越好。必备工具集有： transpiler（编译工具）， bundler（打包工具） 和 hot reloader（热重载）（因为是2015，所以你肯定不希望在重新加载页面上浪费时间）。Browserify 是一个非常棒并且使用起来很简单的 bundler 。更重要的是——它是模块化的，这样你就能在任意时间连接 plugins 和 transforms。Babel 是我们选择的 transpiler，无论你是否使用React，它都很好用。hot reloader 是为了提高开发效率。相对于手动或自动重新加载整个页面，hot reloader 仅仅让浏览器更新部分代码。因此它会很快，并且可以保持应用程序状态，所以你不需要重复之前的操作回到原来的UI状态。本文的例子不是介绍另一个新手工具包，而是教你如何以最少的必备工具开始 ES2015 工程。 新建一个 package.json 并且安装下面的 packages： 1$ npm i -D browserify babelify watchify serve 前三个是 bundler， Babel插件 和 文件监视器， serve 包是一个静态服务器。 将如下代码添加至package.json，这样 Browserify 就会在指定的 stage 下使用 Babel 编译器。 123&#123; &quot;browserify&quot;: &#123; &quot;transform&quot;: [ [&quot;babelify&quot;, &#123;&quot;stage&quot;: [0]&#125;] ]&#125; 最后，这里有一段 NPM 脚本使用 source maps 来启动 bundler 并进入监视模式，且在指定的目录下启动静态服务器。 123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;watchify src/index.js -o public/js/bundle.js -dv &amp; serve public&quot;&#125; 在热模块替代方面，我选择 Browserify 安装如下插件与必备包来重新加载 React 组件：1$ npm i -D livereactload react-proxy babel-plugin-react-transform 新建 .babelrc 文件并添加以下内容。这个会告诉 Babel transform 使用已经安装过的插件。 123456789101112131415&#123; &quot;env&quot;: &#123; &quot;development&quot;: &#123; &quot;plugins&quot;: [ &quot;react-transform&quot; ], &quot;extra&quot;: &#123; &quot;react-transform&quot;: &#123; &quot;transforms&quot;: [&#123; &quot;transform&quot;: &quot;livereactload/babel-transform&quot;, &quot;imports&quot;: [&quot;react&quot;] &#125;] &#125; &#125; &#125; &#125;&#125; 现在将livereactload插件加入 NPM 脚本，然后你就可以开始愉快的玩耍了。 123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;watchify src/index.js -o public/js/bundle.js -dv -p livereactload &amp; serve public&quot;&#125; 若要开发产品或者获取更多深入资料，请访问 GitHub, 你会找到海量现成的模板。 原文链接：Quick ES2015 project setup with Browserify, Babel &amp; hot reloading","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zhouweicsu.github.io/blog/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://zhouweicsu.github.io/blog/tags/ES6/"},{"name":"Browserify","slug":"Browserify","permalink":"http://zhouweicsu.github.io/blog/tags/Browserify/"},{"name":"Babel","slug":"Babel","permalink":"http://zhouweicsu.github.io/blog/tags/Babel/"},{"name":"hot reloading","slug":"hot-reloading","permalink":"http://zhouweicsu.github.io/blog/tags/hot-reloading/"}]},{"title":"「译」深入理解ES6中的解构","date":"2015-08-31T16:00:00.000Z","path":"2015/09/01/es6-destructuring-in-depth/","text":"我曾在React系列文章中简短的提及过一些ES6特性（以及Babel入门），现在我想深入研究这些新的语言特性。在阅读海量ES6与ES7的相关文章之后，我想是时候在Pony Foo的博客中开始讨论ES6与ES7的特性了。 本文开头会给那些ES6新特性的过度使用者一些忠告。接着介绍ES6中的解构，以及解构的使用场景，还有一些陷阱和注意事项，本文是ES6系列的第一篇。 一句忠告当你不确定时，只要能选择，都推荐选择ES5和较旧的语法，而不是ES6。我这样说并不意味着使用ES6语法是一个坏主意，恰恰相反，你看我正在写的关于ES6的文章呢！需要明确的一点是，我们使用ES6特性是因为它会提高我们的代码质量，而不仅仅因为它很酷。 目前为止我写代码都是使用简单的 ES5语法，然后在真的能提高代码质量的地方使用ES6语法糖。相信随着时间的推移，我可以更快速地识别什么情况下使用ES6而不是ES5，但在起步阶段最好不要 过于追求使用ES6的新特性。因此，你首先应该仔细分析最适合你的代码是什么，与此同时也考虑使用ES6。 “通过这种方式，你就能更好的学习使用这些新特性，而不是仅仅学点语法。” 接下来，咱们就开讲这个炫酷特性！ ##解构 解构是ES6中最常用，也是最简单的特性之一。它允许你将数组和对象的属性赋给任何变量。 123456var foo = &#123; bar: 'pony', baz: 3 &#125;var &#123;bar, baz&#125; = fooconsole.log(bar)// &lt;- 'pony'console.log(baz)// &lt;- 3 这样获取对象中某个特定属性将会非常简洁，当然，你也可以将这个属性赋值给某个变量。 123456var foo = &#123; bar: 'pony', baz: 3 &#125;var &#123;bar: a, baz: b&#125; = fooconsole.log(a)// &lt;- 'pony'console.log(b)// &lt;- 3 你可以获取任意深度的属性，并且也可以将这些属性赋值给变量。 123456var foo = &#123; bar: &#123; deep: 'pony', dangerouslySetInnerHTML: 'lol' &#125; &#125;var &#123;bar: &#123; deep, dangerouslySetInnerHTML: sure &#125;&#125; = fooconsole.log(deep)// &lt;- 'pony'console.log(sure)// &lt;- 'lol' 默认情况下，若解构一个未定义的属性时会得到undefined，这与使用点或者括号去访问对象的属性是一致的。 123var &#123;foo&#125; = &#123;bar: 'baz'&#125;console.log(foo)// &lt;- undefined 解构一个不存在的父级元素的深层嵌套的属性时会抛出异常。 12var &#123;foo:&#123;bar&#125;&#125; = &#123;baz: 'ouch'&#125;// &lt;- Exception 假如你认为解构是像以下ES5代码中的语法糖，那么这个异常就很合理了。 123var _temp = &#123; baz: 'ouch' &#125;var bar = _temp.foo.bar// &lt;- Exception 解构还有一个超酷特性，当你交换两个变量的值时不再需要使用臭名昭著的aux变量了。 1234567891011121314151617function es5 () &#123; var left = 10 var right = 20 var aux if (right &gt; left) &#123; aux = right right = left left = aux &#125;&#125;function es6 () &#123; var left = 10 var right = 20 if (right &gt; left) &#123; [left, right] = [right, left] &#125;&#125; 解构另一个特别方便的特性是keys也可以使用计算后属性名（computed property names）。 1234var key = 'such_dynamic'var &#123; [key]: foo &#125; = &#123; such_dynamic: 'bar' &#125;console.log(foo)// &lt;- 'bar' 这在ES5中，你得用一个额外的语句与临时变量来实现。 1234var key = 'such_dynamic'var baz = &#123; such_dynamic: 'bar' &#125;var foo = baz[key]console.log(foo) 当你要解构的属性是undefined时你可以提供一个默认值。 123456789var &#123;foo=3&#125; = &#123; foo: 2 &#125;console.log(foo)// &lt;- 2var &#123;foo=3&#125; = &#123; foo: undefined &#125;console.log(foo)// &lt;- 3var &#123;foo=3&#125; = &#123; bar: 2 &#125;console.log(foo)// &lt;- 3 正如前面提到的，解构在数组中也可以工作。注意我在声明变量时使用了方括号。 123var [a] = [10]console.log(a)// &lt;- 10 数组解构与对象解构一样，也可以使用默认值。 123456789var [a] = []console.log(a)// &lt;- undefinedvar [b=10] = [undefined]console.log(b)// &lt;- 10var [c=10] = []console.log(c)// &lt;- 10 在数组解构中，可以方便地跳过被解构数组中那些你不关心的元素。 12345var [,,a,b] = [1,2,3,4,5]console.log(a)// &lt;- 3console.log(b)// &lt;- 4 在一个function的参数列表中也可以使用解构。 1234567function greet (&#123; age, name:greeting='she' &#125;) &#123; console.log(`$&#123;greeting&#125; is $&#123;age&#125; years old.`)&#125;greet(&#123; name: 'nico', age: 27 &#125;)// &lt;- 'nico is 27 years old'greet(&#123; age: 24 &#125;)// &lt;- 'she is 24 years old' 掌握以上知识点你就知道如何使用解构了。那解构有何用呢？ 解构的应用场景解构在很多情况下都能派上用场。下面我例举一些最常用的场景。首先，我使用最多的一个场景是，在许多模块顶部的import声明中，解构可以从模块的公共API中只加载你需要的模块。举个contra的例子： 1234import &#123;series, concurrent, map &#125; from 'contra'series(tasks, done)concurrent(tasks, done)map(items, mapper, done) 第二个场景，当你的方法返回一个对象时，解构也让赋值变得非常简洁。 1234567891011function getCoords () &#123; return &#123; x: 10, y: 22 &#125;&#125;var &#123;x, y&#125; = getCoords()console.log(x)// &lt;- 10console.log(y)// &lt;- 22 举一个函数的参数使用解构的例子，假设你有一个方法，方法的参数都是可选且需设默认值的，这种情况下你可以使用解构。这与其他语言中（例如Python或者C#）的可选命名参数一样都极其有意思。 1234567function random (&#123; min=1, max=300 &#125;) &#123; return Math.floor(Math.random() * (max - min)) + min&#125;console.log(random(&#123;&#125;)) //必须输入&#123;&#125;，否则报错// &lt;- 174console.log(random(&#123;max: 24&#125;))// &lt;- 18 如果你想让可选对象变成真正的全部可选，你可以将代码修改如下。 12345function random (&#123; min=1, max=300 &#125; = &#123;&#125;) &#123; return Math.floor(Math.random() * (max - min)) + min&#125;console.log(random()) //可以不输入&#123;&#125;// &lt;- 133 解构另外一个非常适合使用的场景就是正则表达式，你只要定义变量接收返回值，不再需要依赖数组索引再取一遍。这里有一个StackOverflow上使用正则表达式解析URL的例子。 1234567891011121314function getUrlParts (url) &#123; var magic = /^(https?):\\/\\/(ponyfoo\\.com)(\\/articles\\/([a-z0-9-]+))$/ return magic.exec(url)&#125;var parts = getUrlParts('http://ponyfoo.com/articles/es6-destructuring-in-depth')var [,protocol,host,pathname,slug] = partsconsole.log(protocol)// &lt;- 'http'console.log(host)// &lt;- 'ponyfoo.com'console.log(pathname)// &lt;- '/articles/es6-destructuring-in-depth'console.log(slug)// &lt;- 'es6-destructuring-in-depth' 原文链接：ES6 JavaScript Destructuring in Depth 译者 @zhouweicsu","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zhouweicsu.github.io/blog/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://zhouweicsu.github.io/blog/tags/ES6/"},{"name":"Destructuring","slug":"Destructuring","permalink":"http://zhouweicsu.github.io/blog/tags/Destructuring/"}]},{"title":"「译」CoffeeScript万岁！ES6万岁！","date":"2015-04-14T16:00:00.000Z","path":"2015/04/15/long-live-coffeescript-and-es6/","text":"显然ES6对ES5来说是一个巨大的改进，并且6to5这类工具使我们可以开始使用这些酷毙了的特性。我之前阅读了Blake Williams的一篇文章Replace CoffeeScript with ES6 （【译】用ES6替代CoffeeScript） ，文章对ES6如何解决许多CoffeeScript解决了的问题做了一个非常好的总结；然而，我想就Blake的几个观点做点评论，并谈谈为什么我将会继续使用CoffeeScript。 类ES6中的类（还有其他ES6中的语法变化）与CoffeeScript的非常相似。为了支持ES5中不兼容的浏览器（例如IE8-），因此，我们仍然不能真正的使用getters/setters，所以忽略这些，比较如下： 123456789101112131415class Person constructor: (@firstName, @lastName) -&gt; name: -&gt; \"#&#123;@firstName&#125; #&#123;@lastName&#125;\" setName: (name) -&gt; [@firstName, @lastName] = name.split \" \" @defaultName: -&gt; \"Unidentified Person\"blake = new Person \"Blake\", \"Williams\"blake.setName \"Blake Anderson\"console.log blake.name() vs 12345678910111213141516171819202122class Person &#123; constructor(firstName, lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125; name() &#123; return `$&#123;this.firstName&#125; $&#123;this.lastName&#125;`; &#125; setName(name) &#123; [this.firstName, this.lastName] = name.split(\" \"); &#125; static defaultName() &#123; return \"Unidentified Person\" &#125;&#125;var blake = new Person(\"Blake\", \"Williams\");blake.setName(\"Blake Anderson\");console.log(blake.name()); 我绝对喜欢ES6的风格——无需逗号，不需要到处写function；但是我是“write less code”派，所以我还是选择前者。然而，这真的是个人品味问题，如果你喜欢this.而不是@，喜欢添加所有额外的大括号，那么这毫无疑问你是支持Blake的观点的，认为ES6是一个更好的选择。 虽然我能理解为什么ES6允许你调用父对象的一种不同的方法，但是我还是得说我更喜欢CoffeeScript中super的实现。 字符串插值很显然ES6与CoffeeScript中的字符串插值非常相似；CoffeeScript的字符串插值使用常规的“strings”，ES6使用`包裹字符串（吐槽：这导致在写Markdown的时候相当烦人）。CoffeeScript使用#{var}，ES6使用${var}。这些点都大同小异。 真正突出的差别是对空白的处理——ES6（或者至少是6to5工具）会保留所有位于` 之间的空格（包括换行和缩进），CoffeeScript的处理时位于简单&quot;中的字符串会将所有空白合并成一个空格，若是位于&quot;&quot;&quot;之间的块级字符串则保留所有空格用来缩进，在我看来这两者的行为都是值得保留的，然而ES6的处理却没有分别处理，举个栗子： 123456789(function() &#123; function foo(bar, val) &#123; if (bar) &#123; var str = `This is quite a long first line so I wrap it to a second line and then append the value $&#123;val&#125;`; &#125; &#125;&#125;)(); 通过6to5 REPL的转化输出是： 1var str = \"This is quite a long first line\\n so I wrap it to a second line and then\\n append the value \" + val; 等价的CoffeeScript代码： 123456789101112do -&gt; foo = (bar, val) -&gt; if bar str = &quot;This is quite a long first line so I wrap it to a second line and then append the value #&#123;val&#125;&quot;; str2 = &quot;&quot;&quot; This is quite a long first line so I wrap it to a second line and then append the value #&#123;val&#125; &quot;&quot;&quot; 编译之后： 12var str = \"This is quite a long first line so I wrap it to a second line and then append the value \" + val;var str2 = \"This is quite a long first line\\nso I wrap it to a second line and then\\nappend the value \" + val; 我实在想不出一个能让我选择6to5的理由。 胖箭头，默认参数这两项是对JS语法的杰出扩展，ES6的表现与CoffeeScript大致相同，只有少量语法不同。 参数列表（splats）另一个杰出扩展，我发现参数列表(splats)这个技能在参数列的中间非常 有用，尤其是在Node.js风格的回调函数的情况下，回调函数可以自动弹出然后退出。举个栗子： 1234567891011121314# Splat dereferencingnames = [\"Alice\", \"Belinda\", \"Catherine\", \"Davidson\"][firstName, middleNames..., lastName] = names# Splat function args preserving callbackfoo = (fn, args..., callback) -&gt; results = (fn arg for arg in args) process.nextTick -&gt; callback null, resultsdouble = (a) -&gt; a * 2foo double, 80, 60, 40, (err, results) -&gt; console.log results 遗憾的是，ES6中只允许splats位于参数列的最后，如果需要你只能使用pop()函数来取回调（或姓氏），让你的代码变得很长，让你选择更多变量名（我们都很讨厌选变量名，不是吗？）： 12345var names = [\"Alice\", \"Belinda\", \"Catherine\", \"Davidson\"];var firstName, middleNames, lastName, rest;[firstName, ...rest] = names;lastName = rest.pop();middleNames = rest; 构造/解构函数我必须承认我很喜欢ES6的一个特性，就是在你写var [first, , last] = [1, 2, 3]赋值语句时可以使用真正的空格，但是用下划线或其他类似字符也可以是一种解决方案。 ES6中对象的构造/解构函数与CoffeeScript几乎一样（var {a, b} = {a: 1, c:3}， var {foo: a, bar: b} = {foo: 1, baz: 3}， 还有var c = {a, b}），但当引用当前对象的属性时，CoffeeScript的做法更好，如c = {@a, @b}（var c = {a: this.a, b: this.b}）。 一些我希望CoffeeScript拥有的ES6特性尝试将CoffeeScript描绘成一个完美的语言是不明智的，它显然不是，它也有缺点，下面给出一个CoffeeScript中没有但ES6（甚至ES3）中有的特性列表： 三元操作符a ? b : c（if a then b else c对我来说太长了，我是决不会放弃？操作符的！） 计算（动态）变量名：{[getKey()]: getValue()}（参考StackOverflow answer，以及一些有趣的历史） 结束语总的来说ES6对JavaScript来说是一个伟大的飞跃，非常感谢所有让这些成为可能的开发者。以上未提及的许多ES6新增的特性都没有涉及语法变化，因此CoffeeScript也可以直接使用，例如Proxies，WeakMaps等。（我们现在甚至还有yield）。 我还是会坚持选择使用CoffeeScript的语法，因为它简明易读，大大提高了我的工作效率。我也很难放弃各种CoffeeScript的语法糖，例如：object?.property，当object是null或者undefined的时候不会报错；a ?= b，a ||= b等；隐式返回；unless；升级版switch；范围缩写[a..b];array/string利用范围arr[2..6]来切割；for own k, v of obj；链式比较 a &lt; b &lt; c；块级正则表达式；还有更多！ CoffeeScript万岁！ES6万岁！原文链接：Long Live CoffeeScript and Long Live ES6 译者 @zhouweicsu 2015 年 4月 15日","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zhouweicsu.github.io/blog/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://zhouweicsu.github.io/blog/tags/ES6/"},{"name":"CoffeeScript","slug":"CoffeeScript","permalink":"http://zhouweicsu.github.io/blog/tags/CoffeeScript/"}]},{"title":"「译」用 ES6 替代 CoffeeScript","date":"2015-03-11T16:00:00.000Z","path":"2015/03/12/replace-coffeescript-with-es6/","text":"一直以来我都在关注和研究JavaScript的下一个版本——ES6，并终于在一个项目中用了它。在短暂的使用过程中，我发现ES6解决了许多CoffeeScript尝试不去大量修改语法想解决的问题。 如何使用ES6我们可以通过6to5这个项目开始使用ES6,6to5可以将ES6代码转译成符合ES5标准的代码。6to5支持数量众多的构建工具，包括Broccoli，Grunt，Gulp，和Sprockets。我在使用sprockets-es6上有许多成功的经验，并且Sprockets 4.x版本将会非常好的支持6to5。 如果你使用Vim编辑器的话，那么你可以通过将如下代码加入你的.vimrc文件，从而将带.es6扩展名的文件与JavaScript关联起来。 1autocmd BufRead,BufNewFile *.es6 setfiletype javascript 你也可以在浏览器中使用6to5 REPL来编写ES6代码。 类CoffeeScript与ES6都支持类。让我们来看下CoffeeScript类与相同功能的ES6类的对比。 CoffeeScript有可以利用的三个优势：参数列表使用实例变量，字符串插值，函数调用不需要括号。 123456789101112131415class Person constructor: (@firstName, @lastName) -&gt; name: -&gt; \"#&#123;@first_name&#125; #&#123;@last_name&#125;\" setName: (name) -&gt; names = name.split \" \" @firstName = names[0] @lastName = names[1]blake = new Person \"Blake\", \"Williams\"blake.setName(\"Blake Anderson\")console.log blake.name() ES6我们可以使用classes、getters和setters： 123456789101112131415161718192021class Person &#123; constructor(firstName, lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125; get name() &#123; return this.firstName + &quot; &quot; + this.lastName; &#125; set name(name) &#123; var names = name.split(&quot; &quot;); this.firstName = names[0]; this.lastName = names[1]; &#125;&#125;var blake = new Person(&quot;Blake&quot;, &quot;Williams&quot;);blake.name = &quot;Blake Anderson&quot;console.log(blake.name); 如果你使用过任何提供类机制的javascript库或框架，你会发现ES6的语法有一点点不同之处： 函数名之后没有分号 关键字function被省略了 每个定义之后都没有逗号了 我们也可以利用getters和setters方法让使用name方法像属性那样方便。 字符串插值我一直希望JavaScript能够拥有更加有方便的字符串语法。幸运地是ES6新加了template strings。下面我们来比较一下CoffeeScript strings，JavaScript strings，和template strings，看看他们的能力。 CoffeeScript: 1234\"CoffeeScript allows multi-line stringswithinterpolation like 1 + 1 = #&#123;1 + 1&#125;\" JavaScript strings: 12\"JavaScript strings can only span a single line \" + \"and interpolation isn't possible\" ES6 template strings: 123`Template strings allow strings to spanmultiple lines and allow interpolation like 1 + 1 = $&#123;1 + 1&#125;` 我们可以在前文给出的例子中使用template strings，将name的getter方法改为如下形式： 123get name() &#123; return `$&#123;this.firstName&#125; $&#123;this.lastName&#125;`;&#125; 这比之前的字符串拼接的方式看起来清爽多了，并且看起来更加像CoffeeScript。 胖箭头另一个CoffeeScript中很吸引人的特性在ES6中也有新增，那就是胖箭头。胖箭头可以将函数与当前上下文的this值绑定起来。首先，让我看看不使用胖箭头函数是如何处理this的。 在ES5中，定义一个函数前必须用一个变量来保存当前的this值： 12345var self = this;$(&quot;button&quot;).on(&quot;click&quot;, function() &#123; // do something with self&#125;); CoffeeScript中使用胖箭头，并且可以省略参数和花括号： 12$(&quot;button&quot;).on&quot;click&quot;, =&gt; # do something with this 在ES6中，花括号是必须的，但是参数可以省略： 123$(&quot;button&quot;).on(&quot;click&quot;, () =&gt; &#123; // do something with this&#125;); 其他特性ES6有一些其他的特性值得顺便提一下。 默认参数CoffeeScript： 12hello = (name = \"guest\") -&gt; alert(name) ES6: 123var hello = function(name = &quot;guest&quot;)&#123; alert(name);&#125; 参数列表（splats）变长参数函数，CoffeeScript称之为参数列表（splats），允许收集附加参数传递给函数作为一个数组。ES6中称之为其他参数。 CoffeeScript: 1234awards = (first, second, others...) -&gt; gold = first silver = second honorable_mention = others ES6: 12345var awards = function(first, second, ...others) &#123; var gold = first; var silver = second; var honorableMention = others;&#125; 解构赋值解构赋值允许按照一定模式，从数组和对象中提取值，对变量进行赋值。 CoffeeScript: 1[first, _, last] = [1, 2, 3] ES6: 1var [first, , last] = [1, 2, 3] 我们可以使用解构赋值将之前定义的name的setter函数代码更加简洁： 123set name(name) &#123; [this.firstName, this.lastName] = name.split(&quot; &quot;);&#125; 结束语许多ES6转译工具已经在积极的开发中，功能上已经可以追上CoffeeScript了。本文仅仅介绍了极少数JavaScript的新特性，但是点击这里找到更多新特性。 下个项目把CoffeeScript放一边，试一试ES6吧！ 原文链接：Replace CoffeeScript with ES6 译者 @zhouweicsu2015 年 3月 15日","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zhouweicsu.github.io/blog/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://zhouweicsu.github.io/blog/tags/ES6/"},{"name":"CoffeeScript","slug":"CoffeeScript","permalink":"http://zhouweicsu.github.io/blog/tags/CoffeeScript/"}]},{"title":"「原」doT 模板中直接写 Javascript 代码导致 Uncaught SyntaxError Unexpected identifier","date":"2015-01-13T16:00:00.000Z","path":"2015/01/14/doT-template-SyntacError/","text":"在使用 doT 的过程中，由于项目需要，我们将电话号码拼成了以逗号分开的字符串 1234/** 初始json对象 **/ var data = &#123; tel:'4008107107,4008107106' &#125; 而页面中需要显示独立的电话号码，这就需要在 doT 模板渲染中使用 Javascript 的 split 方法，将字符串解析成数组。 1234/** 目标json对象 **/ var data = &#123; tel:[4008107107,4008107106] &#125; 我们知道，doT 的原理就是将整个的模板 html 代码放在&lt;script&gt;&lt;/script&gt;标签中，然后生成一段可执行的 Javascript 代码，然后将 JSON 格式的数据传入该函数，return 生成的html代码，而 doT 在生成可执行 Javascript 代码片段的过程中其实就是字符串的解析与拼接。 12/**doT中直接写Javascript代码**/&#123; &#123; it.tel = it.tel.split(&apos;,&apos;) &#125; &#125; 写成上面这样子，页面渲染会报错Uncaught SyntaxError: Unexpected identifier因为在生成Javascript代码片段时该段JS代码被解析字符串 1it.tel = it.tel.split(&apos;,&apos;) 与后一句可执行的JS代码out += &#39;&#39;;拼接之后变成 1it.tel = it.tel.split(&apos;,&apos;) out += &apos;&apos;; doT无法像Javascript解析器一样自动补全分号，这就导致了上面的错误发生。 解决方法加上分号就好了 1&#123; &#123; it.tel = it.tel.split(&apos;,&apos;); &#125; &#125; 由于doT中2个{}套在一起无法被解析，所以在两个花括号之间加入引号 作者 @zhouweicsu","tags":[{"name":"template","slug":"template","permalink":"http://zhouweicsu.github.io/blog/tags/template/"},{"name":"doT","slug":"doT","permalink":"http://zhouweicsu.github.io/blog/tags/doT/"},{"name":"分号","slug":"分号","permalink":"http://zhouweicsu.github.io/blog/tags/分号/"}]},{"title":"「译」手机浏览器下触发touchcancel事件的操作","date":"2014-12-08T16:00:00.000Z","path":"2014/12/09/trigger-touchcancel-in-mobile-browsers/","text":"Touchcancel事件在Javascript创建touch-interfaces时常常被忽视。而浏览器厂商也从未正式发布详细说明touchcancel事件何时会被触发的文档，因此，对于许多开发者而言touchcancel事件一直默默无闻。本贴希望能揭开touchcancel的神秘面纱，助你清楚地了解touchcancel事件。 touch事件最初是Apple为Safari浏览器创建的，现在已经被纳入了W3C Touch 事件规范。原始的Safari DOM参考文档关于touchcancel事件的信息少的可怜，仅有一句话： 当系统取消跟踪touch事件时触发。 幸运地是，W3C Touch事件规范提供了更多的细节，包括一些会触发该事件的场景： 在touch事件被系统自定义行为干扰之后，客户端必须触发touchcancel事件，例如客户端原生的同步事件或操作取消了touch事件，或者触摸点滑出文档窗口移至一个可以处理用户交互的非文档区域（如，客户端原生界面，插件）。另外，当用户放置的触摸点超出了设备可存储的数量，那么最早进入TouchList的Touch对象也将被移除，此时客户端会触发该Touch对象的touchcancel事件。 从上一段描述中我们可以进一步理解touchcancel事件与浏览器行为的关系。这不仅能帮助浏览器精确地引用TouchList中的Touch对象，而且也能被开发者用来实现特定的UI操作，例如在touchstart和touchmove事件处理函数中重置正在使用的变量。当系统取消了跟踪touch事件但touchend事件没有被触发时，touchcancel将会拯救你。 那浏览器什么时候触发这个事件？开始研究之前有必要构建一个简单的事件日志来跟踪所有的touch事件。测试主要记录在touch区域滑动时最后一个被触发的touch事件，这些日志将使我们更加直观地分析到底是哪种交互操作触发了touchcancel事件。 以下是我们在多种手机浏览器上的发现。值得指出的是touchcancel事件很不可预测的，尤其在安卓（2.3.5）上。甚至在iOS5上有时也不能准确预测什么操作会触发touchcancel事件。 iOS Safari 5.0.1（iPhone 4 &amp; iPad 1）在touchstart或touchmove事件被触发时，会触发touchcancel事件的操作： 用户按下home键 用户按下Safari浏览器底部工具栏的操作按钮 用户在屏幕中使用手掌触摸或涂抹，生成了许多不可辨别的单一触摸点（仅iPhone？） 用户在iPad上使用四个或更多手指同时触摸，或使用系统设置中的多任务手势 在touchstart或touchmove事件中不会触发touchcancel事件的操作： 用户按下Safari浏览器底部工具栏中的书签按钮 用户按下Safari浏览器底部工具栏中的前进或回退按钮 用户点击聚焦在Safari浏览器的搜索栏 用户旋转设备的方向 屏幕弹出系统通知，例如WiFi查找或闹钟提醒 屏幕上方弹出iOS5风格的新通知 用户新开了一个tab（iPad） 用户刷新网页 用户按下音量键 用户切换设备静音/振动的开关 用户接到一个来电 在有些情况下以上操作中，浏览器会直接触发一个touchend事件而不是touchcancel事件。在其他情景中（例如旧风格的弹出通知），touchstart和touchmove事件仍然是起作用的（即使内容已经被通知覆盖），除非用户移开手指触发了touchend事件。值得注意的是当touchstart或者touchmove事件被触发时，部分iOS5系统方法是无法执行的： 用户不能使用Safari浏览器的地址栏 用户不能打开一个新页面（iPhone） 用户不能双击home键打开应用盒子（app tray） 用户不能从屏幕上方往下滑动打开通知中心 用户无法打开屏幕上方出现的iOS5风格的通知 安卓2.3.5（Samsung Galaxy Y GT-S5363）内置浏览器在touchstart或touchmove事件被触发时，会触发touchcancel事件的操作： 用户按下锁屏键 此种情况下，似乎没有明显的原因touchcancel事件也会被随机触发，这种现象在重复快速点击和滑动的时候尤其显著 在touchstart或touchmove事件中不会触发touchcancel事件的操作： 用户按下home键 用户旋转设备的方向 用户按下音量键 当touchstart或者touchmove事件被触发时，部分安卓2.3.5系统方法是无法执行的： 用户无法按下菜单键和回退键 用户无法打开通知菜单 用户无法聚焦到浏览器地址栏 用户无法点击书签按钮 Opera Mobile安卓版Opera Mobile 11.50 也测试了。然而浏览器似乎支持touchcancel事件，实际上他并未触发这个事件。例如在按下home键的时候，Opera Mobile似乎直接触发了touchend事件。 黑莓平板电脑 (1.0.8.6067)尽管浏览器声称支持touchcancel事件，但该事件似乎并未被触发。即使按下电源键使设备待机，touchcancel事件也未被触发。同样的，按下浏览器工具条的按钮或聚焦在地址栏都未触发此事件。另外值得注意的是，当触发touchstart或touchmove事件后，平板电脑不会响应任何滑动的手势。 结论从测试结果看，touchcancel事件仍然是不可预测的。然而确定在哪种情况下事件会被触发还是很容易的，在哪种情况下不被触发也几乎能确定。那么这个事件的作用也无需出现在本次研究中，因为在所有可预期的情况下，开发者目前似乎无法依赖这个事件的触发。 然而可以肯定的是，你无法在每台设备上都仅仅只依赖touchend事件被的触发。你需要编写处理touchcancel事件的代码。例如在iPad上尤其如此，假如你写了个多点触控的app或联机的HTML5游戏。由于程序没有办法辨别用户是否启用了多任务手势，这时你的app就需要优雅地处理touchcancel事件。安卓浏览器不可预测的特性也是使得处理这个事件变得尤为重要，不这么做将会导致你的UI出现bug。 所以，当你下次处理touch事件时，别忘记处理touchcancel事件。尽管许多浏览器支持此事件，但在处理某些意想不到的用户交互时还是非常方便的。 原文链接：Different ways to trigger touchcancel in mobile browsers译者 @zhouweicsu2014 年 12月 09日","tags":[{"name":"移动开发","slug":"移动开发","permalink":"http://zhouweicsu.github.io/blog/tags/移动开发/"},{"name":"touchcancel","slug":"touchcancel","permalink":"http://zhouweicsu.github.io/blog/tags/touchcancel/"},{"name":"mobile browsers","slug":"mobile-browsers","permalink":"http://zhouweicsu.github.io/blog/tags/mobile-browsers/"},{"name":"touch","slug":"touch","permalink":"http://zhouweicsu.github.io/blog/tags/touch/"}]}]